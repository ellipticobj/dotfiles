import{_ as m,av as M,aw as j,ax as L,ay as Y,l as a,d as H,az as z,aA as _,ah as q,am as K,ai as O,ag as Q,aB as U,aC as V,aD as W}from"./AugmentMessage-DPQ5COF7.js";import{G as k}from"./graph-BIP8hp58.js";import{l as Z}from"./layout-2IYBi2zb.js";import{i as S}from"./_baseUniq-DK14j0vV.js";import{c as $}from"./clone-SaRvqQLB.js";import{m as B}from"./_basePickBy-CTcDp8vz.js";import"./index-Bg5k1fBH.js";import"./github-DJRJsxRC.js";import"./augment-logo-rit98iY0.js";import"./TextTooltipAugment-BspEVawc.js";import"./IconButtonAugment-CMGBc7C3.js";import"./ButtonAugment-CSwi-JVg.js";import"./Content-DlSDhH-b.js";import"./globals-D0QH3NT1.js";import"./circle-backslash-DcaYy8Cz.js";import"./folder-opened-Bm8IVIHF.js";import"./file-paths-BcSg4gks.js";import"./pen-to-square-DVpukHrw.js";import"./CollapseButtonAugment-BGvJcqaG.js";import"./toggleHighContrast-CwIv4U26.js";import"./preload-helper-Dv6uf1Os.js";import"./keypress-DD1aQVr0.js";import"./await_block-mV9LhbR_.js";import"./expand-DPRXx-qB.js";import"./index-CqmTMtlA.js";import"./ellipsis-D4o8IzPJ.js";import"./IconFilePath-Db9jFTUr.js";import"./LanguageIcon-elXUw7jw.js";import"./next-edit-types-904A5ehg.js";import"./MaterialIcon-BhPUHxOM.js";import"./mcp-logo-BTaOefqG.js";import"./play-B7RwZVmm.js";import"./terminal-BosCzoBy.js";function X(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return S(e.graph())||(r.value=$(e.graph())),r}function ee(e){return B(e.nodes(),function(r){var n=e.node(r),i=e.parent(r),d={v:r};return S(n)||(d.value=n),S(i)||(d.parent=i),d})}function ne(e){return B(e.edges(),function(r){var n=e.edge(r),i={v:r.v,w:r.w};return S(r.name)||(i.name=r.name),S(n)||(i.value=n),i})}var l=new Map,b=new Map,P=new Map,re=m(()=>{b.clear(),P.clear(),l.clear()},"clear"),D=m((e,r)=>{const n=b.get(r)||[];return a.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),te=m((e,r)=>{const n=b.get(r)||[];return a.info("Descendants of ",r," is ",n),a.info("Edge is ",e),e.v!==r&&e.w!==r&&(n?n.includes(e.v)||D(e.v,r)||D(e.w,r)||n.includes(e.w):(a.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),A=m((e,r,n,i)=>{a.warn("Copying children of ",e,"root",i,"data",r.node(e),i);const d=r.children(e)||[];e!==i&&d.push(e),a.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(s=>{if(r.children(s).length>0)A(s,r,n,i);else{const o=r.node(s);a.info("cp ",s," to ",i," with parent ",e),n.setNode(s,o),i!==r.parent(s)&&(a.warn("Setting parent",s,r.parent(s)),n.setParent(s,r.parent(s))),e!==i&&s!==e?(a.debug("Setting parent",s,e),n.setParent(s,e)):(a.info("In copy ",e,"root",i,"data",r.node(e),i),a.debug("Not Setting parent for node=",s,"cluster!==rootId",e!==i,"node!==clusterId",s!==e));const c=r.edges(s);a.debug("Copying Edges",c),c.forEach(p=>{a.info("Edge",p);const E=r.edge(p.v,p.w,p.name);a.info("Edge data",E,i);try{te(p,i)?(a.info("Copying as ",p.v,p.w,E,p.name),n.setEdge(p.v,p.w,E,p.name),a.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):a.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",i," clusterId:",e)}catch(C){a.error(C)}})}a.debug("Removing node",s),r.removeNode(s)})},"copy"),J=m((e,r)=>{const n=r.children(e);let i=[...n];for(const d of n)P.set(d,e),i=[...i,...J(d,r)];return i},"extractDescendants"),ae=m((e,r,n)=>{const i=e.edges().filter(c=>c.v===r||c.w===r),d=e.edges().filter(c=>c.v===n||c.w===n),s=i.map(c=>({v:c.v===r?n:c.v,w:c.w===r?r:c.w})),o=d.map(c=>({v:c.v,w:c.w}));return s.filter(c=>o.some(p=>c.v===p.v&&c.w===p.w))},"findCommonEdges"),I=m((e,r,n)=>{const i=r.children(e);if(a.trace("Searching children of id ",e,i),i.length<1)return e;let d;for(const s of i){const o=I(s,r,n),c=ae(r,n,o);if(o){if(!(c.length>0))return o;d=o}}return d},"findNonClusterChild"),G=m(e=>l.has(e)&&l.get(e).externalConnections&&l.has(e)?l.get(e).id:e,"getAnchorId"),oe=m((e,r)=>{if(!e||r>10)a.debug("Opting out, no graph ");else{a.debug("Opting in, graph "),e.nodes().forEach(function(n){e.children(n).length>0&&(a.warn("Cluster identified",n," Replacement id in edges: ",I(n,e,n)),b.set(n,J(n,e)),l.set(n,{id:I(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const i=e.children(n),d=e.edges();i.length>0?(a.debug("Cluster identified",n,b),d.forEach(s=>{D(s.v,n)^D(s.w,n)&&(a.warn("Edge: ",s," leaves cluster ",n),a.warn("Descendants of XXX ",n,": ",b.get(n)),l.get(n).externalConnections=!0)})):a.debug("Not a cluster ",n,b)});for(let n of l.keys()){const i=l.get(n).id,d=e.parent(i);d!==n&&l.has(d)&&!l.get(d).externalConnections&&(l.get(n).id=d)}e.edges().forEach(function(n){const i=e.edge(n);a.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),a.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let d=n.v,s=n.w;if(a.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(a.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),d=G(n.v),s=G(n.w),e.removeEdge(n.v,n.w,n.name),d!==n.v){const o=e.parent(d);l.get(o).externalConnections=!0,i.fromCluster=n.v}if(s!==n.w){const o=e.parent(s);l.get(o).externalConnections=!0,i.toCluster=n.w}a.warn("Fix Replacing with XXX",d,s,n.name),e.setEdge(d,s,i,n.name)}}),a.warn("Adjusted Graph",X(e)),R(e,0),a.trace(l)}},"adjustClustersAndEdges"),R=m((e,r)=>{var d,s;if(a.warn("extractor - ",r,X(e),e.children("D")),r>10)return void a.error("Bailing out");let n=e.nodes(),i=!1;for(const o of n){const c=e.children(o);i=i||c.length>0}if(i){a.debug("Nodes = ",n,r);for(const o of n)if(a.debug("Extracting node",o,l,l.has(o)&&!l.get(o).externalConnections,!e.parent(o),e.node(o),e.children("D")," Depth ",r),l.has(o))if(!l.get(o).externalConnections&&e.children(o)&&e.children(o).length>0){a.warn("Cluster without external connections, without a parent and with children",o,r);let c=e.graph().rankdir==="TB"?"LR":"TB";(s=(d=l.get(o))==null?void 0:d.clusterData)!=null&&s.dir&&(c=l.get(o).clusterData.dir,a.warn("Fixing dir",l.get(o).clusterData.dir,c));const p=new k({multigraph:!0,compound:!0}).setGraph({rankdir:c,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});a.warn("Old graph before copy",X(e)),A(o,e,p,o),e.setNode(o,{clusterNode:!0,id:o,clusterData:l.get(o).clusterData,label:l.get(o).label,graph:p}),a.warn("New graph after copy node: (",o,")",X(p)),a.debug("Old graph after copy",X(e))}else a.warn("Cluster ** ",o," **not meeting the criteria !externalConnections:",!l.get(o).externalConnections," no parent: ",!e.parent(o)," children ",e.children(o)&&e.children(o).length>0,e.children("D"),r),a.debug(l);else a.debug("Not a cluster",o,r);n=e.nodes(),a.warn("New list of nodes",n);for(const o of n){const c=e.node(o);a.warn(" Now next level",o,c),c!=null&&c.clusterNode&&R(c.graph,r+1)}}else a.debug("Done, no node has children",e.nodes())},"extractor"),T=m((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(i=>{const d=e.children(i),s=T(e,d);n=[...n,...s]}),n},"sorter"),ie=m(e=>T(e,e.children()),"sortNodesByHierarchy"),F=m(async(e,r,n,i,d,s)=>{a.warn("Graph in recursive render:XAX",X(r),d);const o=r.graph().rankdir;a.trace("Dir in recursive render - dir:",o);const c=e.insert("g").attr("class","root");r.nodes()?a.info("Recursive render XXX",r.nodes()):a.info("No nodes found for",r),r.edges().length>0&&a.info("Recursive edges",r.edge(r.edges()[0]));const p=c.insert("g").attr("class","clusters"),E=c.insert("g").attr("class","edgePaths"),C=c.insert("g").attr("class","edgeLabels"),f=c.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(g){const t=r.node(g);if(d!==void 0){const u=JSON.parse(JSON.stringify(d.clusterData));a.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,u.height,`
Parent cluster`,d.height),r.setNode(d.id,u),r.parent(g)||(a.trace("Setting parent",g,d.id),r.setParent(g,d.id,u))}if(a.info("(Insert) Node XXX"+g+": "+JSON.stringify(r.node(g))),t==null?void 0:t.clusterNode){a.info("Cluster identified XBX",g,t.width,r.node(g));const{ranksep:u,nodesep:w}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:u+25,nodesep:w});const N=await F(f,t.graph,n,i,r.node(g),s),x=N.elem;z(t,x),t.diff=N.diff||0,a.info("New compound node after recursive render XAX",g,"width",t.width,"height",t.height),_(x,t)}else r.children(g).length>0?(a.trace("Cluster - the non recursive path XBX",g,t.id,t,t.width,"Graph:",r),a.trace(I(t.id,r)),l.set(t.id,{id:I(t.id,r),node:t})):(a.trace("Node - the non recursive path XAX",g,f,r.node(g),o),await q(f,r.node(g),{config:s,dir:o}))})),await m(async()=>{const g=r.edges().map(async function(t){const u=r.edge(t.v,t.w,t.name);a.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),a.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),a.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v),l.get(t.w)),await W(C,u)});await Promise.all(g)},"processEdges")(),a.info("Graph before layout:",JSON.stringify(X(r))),a.info("############################################# XXX"),a.info("###                Layout                 ### XXX"),a.info("############################################# XXX"),Z(r),a.info("Graph after layout:",JSON.stringify(X(r)));let y=0,{subGraphTitleTotalMargin:v}=K(s);return await Promise.all(ie(r).map(async function(g){var u;const t=r.node(g);if(a.info("Position XBX => "+g+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=v,a.info("A tainted cluster node XBX1",g,t.id,t.width,t.height,t.x,t.y,r.parent(g)),l.get(t.id).node=t,O(t);else if(r.children(g).length>0){a.info("A pure cluster node XBX1",g,t.id,t.x,t.y,t.width,t.height,r.parent(g)),t.height+=v,r.node(t.parentId);const w=(t==null?void 0:t.padding)/2||0,N=((u=t==null?void 0:t.labelBBox)==null?void 0:u.height)||0,x=N-w||0;a.debug("OffsetY",x,"labelHeight",N,"halfPadding",w),await Q(p,t),l.get(t.id).node=t}else{const w=r.node(t.parentId);t.y+=v/2,a.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",w,w==null?void 0:w.offsetY,t),O(t)}})),r.edges().forEach(function(g){const t=r.edge(g);a.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(t),t),t.points.forEach(x=>x.y+=v/2);const u=r.node(g.v);var w=r.node(g.w);const N=U(E,t,l,n,u,w,i);V(t,N)}),r.nodes().forEach(function(g){const t=r.node(g);a.info(g,t.type,t.diff),t.isGroup&&(y=t.diff)}),a.warn("Returning from recursive render XAX",c,y),{elem:c,diff:y}},"recursiveRender"),je=m(async(e,r)=>{var s,o,c,p,E,C;const n=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((s=e.config)==null?void 0:s.nodeSpacing)||((c=(o=e.config)==null?void 0:o.flowchart)==null?void 0:c.nodeSpacing)||e.nodeSpacing,ranksep:((p=e.config)==null?void 0:p.rankSpacing)||((C=(E=e.config)==null?void 0:E.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),i=r.select("g");M(i,e.markers,e.type,e.diagramId),j(),L(),Y(),re(),e.nodes.forEach(f=>{n.setNode(f.id,{...f}),f.parentId&&n.setParent(f.id,f.parentId)}),a.debug("Edges:",e.edges),e.edges.forEach(f=>{if(f.start===f.end){const h=f.start,y=h+"---"+h+"---1",v=h+"---"+h+"---2",g=n.node(h);n.setNode(y,{domId:y,id:y,parentId:g.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(y,g.parentId),n.setNode(v,{domId:v,id:v,parentId:g.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(v,g.parentId);const t=structuredClone(f),u=structuredClone(f),w=structuredClone(f);t.label="",t.arrowTypeEnd="none",t.id=h+"-cyclic-special-1",u.arrowTypeEnd="none",u.id=h+"-cyclic-special-mid",w.label="",g.isGroup&&(t.fromCluster=h,w.toCluster=h),w.id=h+"-cyclic-special-2",n.setEdge(h,y,t,h+"-cyclic-special-0"),n.setEdge(y,v,u,h+"-cyclic-special-1"),n.setEdge(v,h,w,h+"-cyc<lic-special-2")}else n.setEdge(f.start,f.end,{...f},f.id)}),a.warn("Graph at first:",JSON.stringify(X(n))),oe(n),a.warn("Graph after XAX:",JSON.stringify(X(n)));const d=H();await F(i,n,e.type,e.diagramId,void 0,d)},"render");export{je as render};
