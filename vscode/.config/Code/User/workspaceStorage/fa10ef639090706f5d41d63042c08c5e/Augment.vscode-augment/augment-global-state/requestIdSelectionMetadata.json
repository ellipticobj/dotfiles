[["d6125937-df87-498d-a770-e226fb7d86ac",{"value":{"selectedCode":"// main.rs\n// entry point\n\nmod backend;\nmod frontend;\nmod models;\n\nuse std::io::{self, Write};\n\nuse anyhow::Result;\nuse backend::Backend;\nuse frontend::runfrontend;\n\nconst DEBUG: bool = true;\n\nfn main() -> Result<()> {\n    if !DEBUG {\n        // initialize backend\n        let mut backend = Backend::new();\n\n        // start frontend, passing the backend for interaction\n        runfrontend(&mut backend)?;\n\n        // cleanup (handled by frontend for now, or call backend.shutdown() if needed)\n        // backend cleanup\n        backend.shutdown()?;\n\n    } else {\n        println!(\"--- debug CLI ---\");\n        println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n    \n        // initialize the backend\n        let mut backend = Backend::new();\n        // TODO: Maybe load some initial test data into the backend if needed\n        let testtrack = models::Track { title: \"test track\".to_string(), artist: \"unknown\".to_string(), url: \"https://example.com\".to_string() };\n        backend.addplaylist(models::Playlist { name: \"Test Playlist\".to_string(), tracks: vec![] });\n        backend.addtoqueue(testtrack);\n    \n        let mut inputbuffer = String::new();\n    \n        // main command loop\n        loop {\n            print!(\"> \"); // prompt\n            io::stdout().flush()?;\n    \n            // clear the buffer and read the next line\n            inputbuffer.clear();\n            if io::stdin().read_line(&mut inputbuffer)? == 0 {\n                // handle eof\n                println!(\"exiting...\");\n                break;\n            }\n    \n            // parse the input\n            let parts: Vec<&str> = inputbuffer.trim().split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n    \n            let command = parts[0];\n            let args = &parts[1..];\n    \n            // execute commands\n            match command {\n                \"play\" => {\n                    if let Err(e) = backend.playpause() {\n                        println!(\"error playing: {}\", e);\n                    } else {\n                        println!(\"play command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate());\n                }\n                \"pause\" => {\n                    if let Err(e) = backend.playpause() {\n                        println!(\"error pausing: {}\", e);\n                    } else {\n                        println!(\"pause command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate());\n                }\n                \"next\" => {\n                    if let Err(e) = backend.next() {\n                        println!(\"error going to next track: {}\", e);\n                    } else {\n                        println!(\"next command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong());\n                }\n                \"prev\" => {\n                    if let Err(e) = backend.prev() {\n                        println!(\"error going to previous track: {}\", e);\n                    } else {\n                        println!(\"prev command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong());\n                }\n                \"state\" => {\n                    // print the current backend state\n                    println!(\"{:#?}\", backend::get::state());\n                }\n                \"add\" => {\n                    if args.len() == 1 {\n                        let url = args[0].to_string();\n                        // create a dummy track for testing\n                        let track = models::Track {\n                            title: format!(\"track at {}\", url),\n                            artist: \"unknown\".to_string(),\n                            url,\n                        };\n                        backend.addtoqueue(track);\n                        println!(\"added track to queue.\");\n                    } else {\n                        println!(\"usage: add <url>\");\n                    }\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state().player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"queue\" => {\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state().player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"exit\" | \"quit\" | \"q\" => {\n                    println!(\"exiting...\");\n                    break;\n                }\n                \"help\" => {\n                    println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n                }\n                _ => {\n                    println!(\"unknown command: {}\", command);\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","prefix":"","suffix":"","path":"src/main.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["d781b006-0eba-4628-a930-61ff2e9818dd",{"value":{"selectedCode":"","prefix":"// set.rs\n// backend write api\n\nuse super::Backend;\nuse crate::models::*;\nuse anyhow::Result;\nuse rand::{seq::SliceRandom, rng};\nuse std::process::{Command, Stdio};\n\nimpl Backend {\n    // --- play/pause ---\n    /// plays or pauses the current track depending on current state\n    ///\n    /// # arguments\n    /// - none\n    /// \n    /// # returns\n    /// - none\n","suffix":"    pub fn playpause(&mut self) -> Result<()> {\n        if self.state.player.isplaying {\n            self.pause()?;\n        } else {\n            self.unpause()?;\n        }\n        Ok(())\n    }\n\n    /// unpauses the current track in the queue\n    /// \n    /// # arguments\n    /// - none\n    /// \n    /// # returns\n    /// - none\n    fn unpause(&mut self) -> Result<()> {\n        let echooutput = Command::new(\"echo\")\n            .arg(r#\"{\"command\": [\"cycle\", \"pause\"]}\"#)\n            .stdout(Stdio::piped())\n            .spawn()?;\n        \n        if let Some(echoout) = echooutput.stdout {\n            let socatout = Command::new(\"socat\")\n                .arg(\"-\")\n                .arg(\"/tmp/mpvlayer\")\n                .stdin(Stdio::from(echoout)) \n                .stdout(Stdio::null()) \n                .stderr(Stdio::piped()) \n                .output()?;\n            if !socatout.status.success() {\n                let stderr = String::from_utf8_lossy(&socatout.stderr);\n                eprintln!(\"failed to send pause command to mpv: {}\", stderr);\n            }\n        } else {\n            eprintln!(\"failed to get stdout from echo command\");\n        }\n        self.state.player.isplaying = false;\n        Ok(())\n    }\n\n    /// pauses playback\n    /// sends a pause command to mpv using sockets \n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    fn pause(&mut self) -> Result<()> {\n        let echooutput = Command::new(\"echo\")\n            .arg(r#\"{\"command\": [\"cycle\", \"pause\"]}\"#)\n            .stdout(Stdio::piped())\n            .spawn()?;\n        \n        if let Some(echoout) = echooutput.stdout {\n            let socatout = Command::new(\"socat\")\n                .arg(\"-\")\n                .arg(\"/tmp/mpvlayer\")\n                .stdin(Stdio::from(echoout)) \n                .stdout(Stdio::null()) \n                .stderr(Stdio::piped()) \n                .output()?;\n            if !socatout.status.success() {\n                let stderr = String::from_utf8_lossy(&socatout.stderr);\n                eprintln!(\"failed to send pause command to mpv: {}\", stderr);\n            }\n        } else {\n            eprintln!(\"failed to get stdout from echo command\");\n        }\n        self.state.player.isplaying = false;\n        Ok(())\n    }\n\n    /// plays next track in queue\n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    pub fn next(&mut self) -> Result<()> {\n        if let Some(track) = self.state.player.queuestate.queue.get(0).cloned() {\n            self.state.player.queuestate.history.push(track);\n            self.state.player.queuestate.queue.remove(0);\n            self.handlerepeat()?;\n        }\n        Ok(())\n    }\n\n    /// plays previous track (last track in history)\n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    pub fn prev(&mut self) -> Result<()> {\n        if let Some(track) = self.state.player.queuestate.history.pop() {\n            self.state.player.queuestate.queue.insert(0, track);\n        }\n        self.playsong()?;\n        Ok(())\n    }\n\n    /// toggles shuffle\n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    pub fn toggleshuffle(&mut self) {\n        self.state.player.shufflestate.shuffle = !self.state.player.shufflestate.shuffle;\n        self.shufflequeue();\n    }\n\n    fn shufflequeue(&mut self) {\n        if self.state.player.shufflestate.shuffle && self.state.player.queuestate.queue.len() > 1 {\n            if self.state.player.shufflestate.originalqueue.is_empty() {\n                self.state.player.shufflestate.originalqueue = self.state.player.queuestate.queue.clone();\n            }\n            \n            let current = self.state.player.queuestate.queue.remove(0);\n            \n            self.state.player.queuestate.queue.shuffle(&mut rng());\n            \n            self.state.player.queuestate.queue.insert(0, current);\n        } else if !self.state.player.shufflestate.shuffle {\n            if !self.state.player.shufflestate.originalqueue.is_empty() {\n                self.state.player.queuestate.queue = self.state.player.shufflestate.originalqueue.clone();\n                self.state.player.shufflestate.originalqueue.clear();\n            }\n        }\n    }\n\n    /// cycles through repeat modes\n    /// None -> One -> All -> None\n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    pub fn cyclerepeat(&mut self) {\n        self.state.player.repeatstate.repeatmode = match self.state.player.repeatstate.repeatmode {\n            RepeatMode::None => RepeatMode::One,\n            RepeatMode::One => RepeatMode::All,\n            RepeatMode::All => RepeatMode::None\n        };\n    }\n\n    fn handlerepeat(&mut self) -> Result<()> {\n        if self.state.player.queuestate.queue.is_empty() {\n            match self.state.player.repeatstate.repeatmode {\n                RepeatMode::None => {\n                    // do nothing\n                },\n                RepeatMode::One => {\n                    // if we just played a track, put it back in the queue\n                    if let Some(last_track) = self.state.player.queuestate.history.last().cloned() {\n                        self.state.player.queuestate.queue.insert(0, last_track);\n                        self.playsong()?;\n                    }\n                },\n                RepeatMode::All => {\n                    // move all history back to queue and start again\n                    let mut history = Vec::new();\n                    std::mem::swap(&mut history, &mut self.state.player.queuestate.history);\n                    history.reverse(); // To maintain original order\n                    self.state.player.queuestate.queue = history;\n                    if !self.state.player.queuestate.queue.is_empty() {\n                        self.playsong()?;\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    // ---queue and playlist management ---\n\n    /// sets the playback queue\n    ///\n    /// # arguments\n    /// - tracks (Vec<Track>): tracks to set as queue\n    /// - clearhistory (bool): whether to clear the playback history\n    ///\n    /// # returns\n    /// - none\n    pub fn setqueue(&mut self, tracks: Vec<Track>, clearhistory: bool) {\n        self.state.player.queuestate.queue = tracks;\n        if clearhistory {\n            self.state.player.queuestate.history.clear();\n        }\n    }\n\n    /// adds a song to the end of the queue\n    ///\n    /// # arguments\n    /// - track (Track): track to add\n    ///\n    /// # returns\n    /// - none\n    pub fn addtoqueue(&mut self, track: Track) {\n        self.state.player.queuestate.queue.push(track);\n    }\n\n    /// adds a song to the start of the queue\n    ///\n    /// # arguments\n    /// - track (Track): track to add\n    ///\n    /// # returns\n    /// - none\n    pub fn playnext(&mut self, track: Track) {\n        self.state.player.queuestate.queue.insert(0, track);\n    }\n\n    pub fn playtrackfromqueue(&mut self, index: usize) -> Result<()> {\n        if let Some(track) = self.state.player.queuestate.queue.get(index).cloned() {\n            self.state.player.queuestate.history.push(track);\n            self.state.player.queuestate.queue.remove(index);\n        }\n        self.playsong()?;\n        Ok(())\n    }\n\n    pub fn addplaylist(&mut self, playlist: Playlist) {\n        self.state.playlists.push(playlist)\n    }\n\n    /// selects playlist\n    ///\n    /// # arguments\n    /// - index (usize): index to select\n    ///\n    /// # returns\n    /// - none\n    pub fn selectplaylist(&mut self, index: usize) -> Result<()> {\n        if index <= self.state.playlists.len() {\n            self.selection.selectedplaylist = Some(index);\n        } else if !self.state.playlists.is_empty() { \n            self.selection.selectedplaylist = Some(self.state.playlists.len());\n        } else {\n            self.selection.selectedplaylist = None;\n        }\n        Ok(())\n    }\n\n    fn playsong(&mut self) -> Result<()> {\n        if self.state.player.queuestate.queue.is_empty() {\n            return Ok(());\n        }\n        \n        let currenturl = &self.state.player.queuestate.queue[0].url;\n        \n        if let Some(mut process) = self.mpvprocess.take() {\n            let _ = process.kill();\n        }\n        \n        self.mpvprocess = Some(Command::new(\"mpv\")\n            .arg(currenturl)\n            .arg(\"--input-ipc-server=/tmp/mpvlayer\")\n            .arg(\"--no-video\")\n            .arg(\"--no-terminal\")\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .spawn()?);\n        \n        self.state.player.isplaying = true;\n        Ok(())\n    }\n\n    // --- navigation ---\n\n    /// selects the next column, stops at queue\n    /// playlists > tracks > queue > queue\n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    pub fn nextcolumn(&mut self) {\n        self.selection.selectedcolumn = match self.selection.selectedcolumn {\n            CurrentColumn::Playlists => CurrentColumn::Tracks,\n            CurrentColumn::Tracks => CurrentColumn::Queue,\n            CurrentColumn::Queue => CurrentColumn::Queue,\n        };\n    }\n\n    /// selects the previous column, stops at playlists\n    /// playlists < playlists < tracks < queue\n    ///\n    /// # arguments\n    /// - none\n    ///\n    /// # returns\n    /// - none\n    pub fn prevcolumn(&mut self) {\n        self.selection.selectedcolumn = match self.selection.selectedcolumn {\n            CurrentColumn::Playlists => CurrentColumn::Playlists,\n            CurrentColumn::Tracks => CurrentColumn::Playlists,\n            CurrentColumn::Queue => CurrentColumn::Tracks,\n        };\n    }\n\n    /// selects the next row, stops at the last one\n    pub fn nextrow(&mut self) {\n        match self.selection.selectedcolumn {\n            CurrentColumn::Playlists => {\n                let current = self.selection.selectedplaylist.unwrap_or(0);\n                let numberofplaylists = self.state.playlists.len();\n                let next = if current + 1 >= numberofplaylists {\n                    numberofplaylists // change to 0 to cycle\n                } else {\n                    current + 1\n                };\n                self.selection.selectedplaylist = Some(next);\n            },\n            CurrentColumn::Tracks => {\n                if let Some(playlistidx) = self.selection.selectedplaylist {\n                    if let Some(playlist) = self.state.playlists.get(playlistidx) {\n                        let current = self.selection.selectedtrack.unwrap_or(0);\n                        let numberoftracks = playlist.tracks.len();\n                        let next = if current + 1 >= numberoftracks {\n                            numberoftracks // change to 0 to cycle\n                        } else {\n                            current + 1\n                        };\n                        self.selection.selectedtrack = Some(next);\n                    }\n                }\n            },\n            CurrentColumn::Queue => {\n                let current = self.selection.selectedtrack.unwrap_or(0);\n                let queuelength = self.state.player.queuestate.queue.len();\n                let next = if current >= queuelength - 1 {\n                    queuelength // change to 0 to cycle\n                } else {\n                    current + 1\n                };\n                self.selection.selectedtrack = Some(next);\n            }\n        }\n    }\n\n    pub fn prevrow(&mut self) {\n        match self.selection.selectedcolumn {\n            CurrentColumn::Playlists => {\n                let current = self.selection.selectedplaylist.unwrap_or(0);\n                let next = if current <= 0 {\n                    0\n                } else {\n                    current - 1\n                };\n                self.selection.selectedplaylist = Some(next);\n            },\n            CurrentColumn::Tracks => {\n                if let Some(playlistidx) = self.selection.selectedplaylist {\n                    if let Some(playlist) = self.state.playlists.get(playlistidx) {\n                        let current = self.selection.selectedtrack.unwrap_or(0);\n                        let next = if current <= 0 {\n                            0\n                        } else {\n                            current - 1\n                        };\n                        self.selection.selectedtrack = Some(next);\n                    }\n                }\n            },\n            CurrentColumn::Queue => {\n                let current = self.selection.selectedtrack.unwrap_or(0);\n                let next = if current <= 0 {\n                    0\n                } else {\n                    current - 1\n                };\n                self.selection.selectedtrack = Some(next);\n            }\n        }\n    }\n}","path":"src/backend/set.rs","language":"rust","prefixBegin":0,"suffixEnd":1}}],["baaf9932-b29e-4689-9c4f-c89fdb2a3584",{"value":{"selectedCode":"        backend.shutdown()?;","prefix":"// main.rs\n// entry point\n\nmod backend;\nmod frontend;\nmod models;\n\nuse std::io::{self, Write};\n\nuse anyhow::Result;\nuse backend::Backend;\nuse frontend::runfrontend;\n\nconst DEBUG: bool = true;\n\nfn main() -> Result<()> {\n    if !DEBUG {\n        // initialize backend\n        backend::get::initbackend(Backend::new());\n\n        // start frontend, passing the backend for interaction\n        runfrontend()?;\n\n        // cleanup (handled by frontend for now, or call backend.shutdown() if needed)\n        // backend cleanup\n","suffix":"\n\n    } else {\n        println!(\"--- debug CLI ---\");\n        println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n    \n        // initialize the backend\n        backend::get::initbackend(Backend::new());\n\n        // dummy track\n        let testtrack = models::Track { title: \"test track\".to_string(), artist: \"unknown\".to_string(), url: \"https://example.com\".to_string() };\n        backend::set::addplaylist(models::Playlist { name: \"Test Playlist\".to_string(), tracks: vec![] });\n        backend::set::addtoqueue(testtrack);\n    \n        let mut inputbuffer = String::new();\n    \n        // main command loop\n        loop {\n            print!(\"> \"); // prompt\n            io::stdout().flush()?;\n    \n            // clear the buffer and read the next line\n            inputbuffer.clear();\n            if io::stdin().read_line(&mut inputbuffer)? == 0 {\n                // handle eof\n                println!(\"exiting...\");\n                break;\n            }\n    \n            // parse the input\n            let parts: Vec<&str> = inputbuffer.trim().split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n    \n            let command = parts[0];\n            let args = &parts[1..];\n    \n            // execute commands\n            match command {\n                \"play\" => {\n                    if let Err(e) = backend::set::playpause() {\n                        println!(\"error playing: {}\", e);\n                    } else {\n                        println!(\"play command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate());\n                }\n                \"pause\" => {\n                    if let Err(e) = backend::set::playpause() {\n                        println!(\"error pausing: {}\", e);\n                    } else {\n                        println!(\"pause command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate());\n                }\n                \"next\" => {\n                    if let Err(e) = backend::set::next() {\n                        println!(\"error going to next track: {}\", e);\n                    } else {\n                        println!(\"next command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong());\n                }\n                \"prev\" => {\n                    if let Err(e) = backend::set::prev() {\n                        println!(\"error going to previous track: {}\", e);\n                    } else {\n                        println!(\"prev command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong());\n                }\n                \"state\" => {\n                    // print the current backend state\n                    println!(\"{:#?}\", backend::get::state());\n                }\n                \"add\" => {\n                    if args.len() == 1 {\n                        let url = args[0].to_string();\n                        // create a dummy track for testing\n                        let track = models::Track {\n                            title: format!(\"track at {}\", url),\n                            artist: \"unknown\".to_string(),\n                            url,\n                        };\n                        backend::set::addtoqueue(track);\n                        println!(\"added track to queue.\");\n                    } else {\n                        println!(\"usage: add <url>\");\n                    }\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state().player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"queue\" => {\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state().player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"exit\" | \"quit\" | \"q\" => {\n                    println!(\"exiting...\");\n                    break;\n                }\n                \"help\" => {\n                    println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n                }\n                _ => {\n                    println!(\"unknown command: {}\", command);\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","path":"src/main.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["04ee0427-363f-4895-bdb7-772cf0df3f36",{"value":{"selectedCode":"        backend::get::backend().shutdown()?;","prefix":"// main.rs\n// entry point\n\nmod backend;\nmod frontend;\nmod models;\n\nuse std::io::{self, Write};\n\nuse anyhow::Result;\nuse backend::Backend;\nuse frontend::runfrontend;\n\nconst DEBUG: bool = true;\n\nfn main() -> Result<()> {\n    if !DEBUG {\n        // initialize backend\n        backend::get::initbackend(Backend::new());\n\n        // start frontend, passing the backend for interaction\n        runfrontend()?;\n\n        // cleanup (handled by frontend for now, or call backend.shutdown() if needed)\n        // backend cleanup\n","suffix":"\n\n    } else {\n        println!(\"--- debug CLI ---\");\n        println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n    \n        // initialize the backend\n        backend::get::initbackend(Backend::new());\n\n        // dummy track\n        let testtrack = models::Track { title: \"test track\".to_string(), artist: \"unknown\".to_string(), url: \"https://example.com\".to_string() };\n        backend::set::addplaylist(models::Playlist { name: \"Test Playlist\".to_string(), tracks: vec![] });\n        backend::set::addtoqueue(testtrack);\n    \n        let mut inputbuffer = String::new();\n    \n        // main command loop\n        loop {\n            print!(\"> \"); // prompt\n            io::stdout().flush()?;\n    \n            // clear the buffer and read the next line\n            inputbuffer.clear();\n            if io::stdin().read_line(&mut inputbuffer)? == 0 {\n                // handle eof\n                println!(\"exiting...\");\n                break;\n            }\n    \n            // parse the input\n            let parts: Vec<&str> = inputbuffer.trim().split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n    \n            let command = parts[0];\n            let args = &parts[1..];\n    \n            // execute commands\n            match command {\n                \"play\" => {\n                    if let Err(e) = backend::set::playpause() {\n                        println!(\"error playing: {}\", e);\n                    } else {\n                        println!(\"play command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate());\n                }\n                \"pause\" => {\n                    if let Err(e) = backend::set::playpause() {\n                        println!(\"error pausing: {}\", e);\n                    } else {\n                        println!(\"pause command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate());\n                }\n                \"next\" => {\n                    if let Err(e) = backend::set::next() {\n                        println!(\"error going to next track: {}\", e);\n                    } else {\n                        println!(\"next command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong());\n                }\n                \"prev\" => {\n                    if let Err(e) = backend::set::prev() {\n                        println!(\"error going to previous track: {}\", e);\n                    } else {\n                        println!(\"prev command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong());\n                }\n                \"state\" => {\n                    // print the current backend state\n                    println!(\"{:#?}\", backend::get::state());\n                }\n                \"add\" => {\n                    if args.len() == 1 {\n                        let url = args[0].to_string();\n                        // create a dummy track for testing\n                        let track = models::Track {\n                            title: format!(\"track at {}\", url),\n                            artist: \"unknown\".to_string(),\n                            url,\n                        };\n                        backend::set::addtoqueue(track);\n                        println!(\"added track to queue.\");\n                    } else {\n                        println!(\"usage: add <url>\");\n                    }\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state().player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"queue\" => {\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state().player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"exit\" | \"quit\" | \"q\" => {\n                    println!(\"exiting...\");\n                    break;\n                }\n                \"help\" => {\n                    println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n                }\n                _ => {\n                    println!(\"unknown command: {}\", command);\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","path":"src/main.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["da3ea9eb-bb13-4b36-9819-9adc3bc481d3",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::backend::{self, Backend};\nuse crate::models::CurrentColumn;\n\npub fn runfrontend(backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        terminal.draw(|frame| {\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n","suffix":"        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        // TODO: call backend methods to update player state\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    mut backend: Backend,\n    running: &mut bool,\n    currentcolumn: &mut CurrentColumn,\n    playliststate: &mut ListState,\n    tracksstate: &mut ListState,\n    queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // TODO: Handle popup if active (close on Enter/Esc)\n    // if app.popup.onscreen { ... }\n\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(&mut backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(&mut backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(&mut backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(&mut backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(&mut backend),\n        // TODO: Navigation (Up/Down/Left/Right) to update UI state\n        KeyCode::Up => backend::set::prevrow(&mut backend),\n        KeyCode::Down => backend::set::nextrow(&mut backend),\n        KeyCode::Left => backend::set::prevcolumn(&mut backend),\n        KeyCode::Right => backend::set::nextcolumn(&mut backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["0ddc715c-03ce-4c4f-b798-9dbe8fe5f287",{"value":{"selectedCode":"        backend.shutdown()?;","prefix":"// main.rs\n// entry point\n\nmod backend;\nmod frontend;\nmod models;\n\nuse std::io::{self, Write};\n\nuse anyhow::Result;\nuse backend::Backend;\nuse frontend::runfrontend;\n\nconst DEBUG: bool = true;\n\nfn main() -> Result<()> {\n    if DEBUG {\n        println!(\"--- debug CLI ---\");\n        println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n    \n        // initialize the backend\n        let backend = Backend::new();\n\n        // dummy track\n        let testtrack = models::Track { title: \"losing interest\".to_string(), artist: \"adore\".to_string(), url: \"https://www.youtube.com/watch?v=HtR4PkPJiBk\".to_string() };\n        let testtrack1 = models::Track { title: \"losing interest but again\".to_string(), artist: \"adore\".to_string(), url: \"https://www.youtube.com/watch?v=HtR4PkPJiBk\".to_string() };\n        backend::set::addplaylist(&mut backend, models::Playlist { name: \"sigma 1\".to_string(), tracks: vec![testtrack.clone()] });\n        backend::set::addplaylist(&mut backend, models::Playlist { name: \"sigma 2\".to_string(), tracks: vec![testtrack1.clone()] });\n        backend::set::addtoqueue(&mut backend, testtrack);\n        backend::set::addtoqueue(&mut backend, testtrack1);\n    \n        let mut inputbuffer = String::new();\n    \n        // main command loop\n        loop {\n            print!(\"> \"); // prompt\n            io::stdout().flush()?;\n    \n            // clear the buffer and read the next line\n            inputbuffer.clear();\n            if io::stdin().read_line(&mut inputbuffer)? == 0 {\n                // handle eof\n                println!(\"exiting...\");\n                break;\n            }\n    \n            // parse the input\n            let parts: Vec<&str> = inputbuffer.trim().split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n    \n            let command = parts[0];\n            let args = &parts[1..];\n    \n            // execute commands\n            match command {\n                \"play\" => {\n                    if let Err(e) = backend::set::playpause(&mut backend, ) {\n                        println!(\"error playing: {}\", e);\n                    } else {\n                        println!(\"play command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate(&backend));\n                }\n                \"pause\" => {\n                    if let Err(e) = backend::set::playpause(&mut backend, ) {\n                        println!(\"error pausing: {}\", e);\n                    } else {\n                        println!(\"pause command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate(&backend));\n                }\n                \"next\" => {\n                    if let Err(e) = backend::set::next(&mut backend, ) {\n                        println!(\"error going to next track: {}\", e);\n                    } else {\n                        println!(\"next command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong(&backend));\n                }\n                \"prev\" => {\n                    if let Err(e) = backend::set::prev(&mut backend, ) {\n                        println!(\"error going to previous track: {}\", e);\n                    } else {\n                        println!(\"prev command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong(&backend));\n                }\n                \"state\" => {\n                    // print the current backend state\n                    println!(\"{:#?}\", backend::get::state(&backend));\n                }\n                \"add\" => {\n                    if args.len() == 1 {\n                        let url = args[0].to_string();\n                        // create a dummy track for testing\n                        let track = models::Track {\n                            title: format!(\"track at {}\", url),\n                            artist: \"unknown\".to_string(),\n                            url,\n                        };\n                        backend::set::addtoqueue(&mut backend, track);\n                        println!(\"added track to queue.\");\n                    } else {\n                        println!(\"usage: add <url>\");\n                    }\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state(&backend).player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"queue\" => {\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state(&backend).player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"exit\" | \"quit\" | \"q\" => {\n                    println!(\"exiting...\");\n                    break;\n                }\n                \"help\" => {\n                    println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n                }\n                _ => {\n                    println!(\"unknown command: {}\", command);\n                }\n            }\n        }\n    } else {\n        // initialize backend\n        let backend = Backend::new();\n\n        // start frontend, passing the backend for interaction\n        runfrontend(backend)?;\n\n        // cleanup (handled by frontend for now, or call backend.shutdown() if needed)\n        // backend cleanup\n","suffix":"\n\n    } \n\n    Ok(())\n}\n","path":"src/main.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["89432fb9-55a9-47e3-90e8-2581a3f2542e",{"value":{"selectedCode":"        backend::Backend::shutdown(&mut backend)?;","prefix":"// main.rs\n// entry point\n\nmod backend;\nmod frontend;\nmod models;\n\nuse std::io::{self, Write};\n\nuse anyhow::Result;\nuse backend::Backend;\nuse frontend::runfrontend;\n\nconst DEBUG: bool = true;\n\nfn main() -> Result<()> {\n    if DEBUG {\n        println!(\"--- debug CLI ---\");\n        println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n    \n        // initialize the backend\n        let backend = Backend::new();\n\n        // dummy track\n        let testtrack = models::Track { title: \"losing interest\".to_string(), artist: \"adore\".to_string(), url: \"https://www.youtube.com/watch?v=HtR4PkPJiBk\".to_string() };\n        let testtrack1 = models::Track { title: \"losing interest but again\".to_string(), artist: \"adore\".to_string(), url: \"https://www.youtube.com/watch?v=HtR4PkPJiBk\".to_string() };\n        backend::set::addplaylist(&mut backend, models::Playlist { name: \"sigma 1\".to_string(), tracks: vec![testtrack.clone()] });\n        backend::set::addplaylist(&mut backend, models::Playlist { name: \"sigma 2\".to_string(), tracks: vec![testtrack1.clone()] });\n        backend::set::addtoqueue(&mut backend, testtrack);\n        backend::set::addtoqueue(&mut backend, testtrack1);\n    \n        let mut inputbuffer = String::new();\n    \n        // main command loop\n        loop {\n            print!(\"> \"); // prompt\n            io::stdout().flush()?;\n    \n            // clear the buffer and read the next line\n            inputbuffer.clear();\n            if io::stdin().read_line(&mut inputbuffer)? == 0 {\n                // handle eof\n                println!(\"exiting...\");\n                break;\n            }\n    \n            // parse the input\n            let parts: Vec<&str> = inputbuffer.trim().split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n    \n            let command = parts[0];\n            let args = &parts[1..];\n    \n            // execute commands\n            match command {\n                \"play\" => {\n                    if let Err(e) = backend::set::playpause(&mut backend, ) {\n                        println!(\"error playing: {}\", e);\n                    } else {\n                        println!(\"play command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate(&backend));\n                }\n                \"pause\" => {\n                    if let Err(e) = backend::set::playpause(&mut backend, ) {\n                        println!(\"error pausing: {}\", e);\n                    } else {\n                        println!(\"pause command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate(&backend));\n                }\n                \"next\" => {\n                    if let Err(e) = backend::set::next(&mut backend, ) {\n                        println!(\"error going to next track: {}\", e);\n                    } else {\n                        println!(\"next command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong(&backend));\n                }\n                \"prev\" => {\n                    if let Err(e) = backend::set::prev(&mut backend, ) {\n                        println!(\"error going to previous track: {}\", e);\n                    } else {\n                        println!(\"prev command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong(&backend));\n                }\n                \"state\" => {\n                    // print the current backend state\n                    println!(\"{:#?}\", backend::get::state(&backend));\n                }\n                \"add\" => {\n                    if args.len() == 1 {\n                        let url = args[0].to_string();\n                        // create a dummy track for testing\n                        let track = models::Track {\n                            title: format!(\"track at {}\", url),\n                            artist: \"unknown\".to_string(),\n                            url,\n                        };\n                        backend::set::addtoqueue(&mut backend, track);\n                        println!(\"added track to queue.\");\n                    } else {\n                        println!(\"usage: add <url>\");\n                    }\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state(&backend).player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"queue\" => {\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state(&backend).player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"exit\" | \"quit\" | \"q\" => {\n                    println!(\"exiting...\");\n                    break;\n                }\n                \"help\" => {\n                    println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n                }\n                _ => {\n                    println!(\"unknown command: {}\", command);\n                }\n            }\n        }\n    } else {\n        // initialize backend\n        let mut backend = Backend::new();\n\n        // start frontend, passing the backend for interaction\n        runfrontend(backend)?;\n\n        // cleanup (handled by frontend for now, or call backend.shutdown() if needed)\n        // backend cleanup\n","suffix":"\n    } \n\n    Ok(())\n}\n","path":"src/main.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["98ee917f-4c0a-4c2e-a12d-ce2c7a454843",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{PlayerState, Playlist, RepeatMode, RepeatState}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.size();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track))\n                .unwrap_or_else(|| getsonginfocont(&Track::default())); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n","suffix":"        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    currentcolumn: &mut CurrentColumn,\n    playliststate: &mut ListState,\n    tracksstate: &mut ListState,\n    queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n\nfn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat \n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\nfn getsonginfocont(queue: &Vec<Track>, shuffle: bool, repeat: RepeatMode) -> Paragraph<'static> {\n    // --- check if the index points to a valid track ---\n    let displaytext: String = if !queue.is_empty() {\n        // --- valid track ---\n        let currenttrack = &queue[0];\n\n        if currenttrack.artist.is_empty() {\n            String::from(format!(\" {} \", currenttrack.title))\n        } else if currenttrack.title.is_empty() {\n            String::from(format!(\" Unknown Track - {} \", currenttrack.artist))\n        } else {\n            String::from(format!(\" {} - {} \", currenttrack.title, currenttrack.artist))\n        }\n    } else {\n        // --- no valid track (empty queue) ---\n        String::from(\" no song playing \")\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = ratatui::text::Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["e28ad47c-13b5-448d-ae8e-b2cb5f28bdc1",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    _currentcolumn: &mut CurrentColumn,\n    _playliststate: &mut ListState,\n    _tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n","suffix":"    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["b2695738-2d9e-4287-b6f7-159565255f9c",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    _currentcolumn: &mut CurrentColumn,\n    _playliststate: &mut ListState,\n    _tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n","suffix":"    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["dc485722-d5ff-4370-9c17-eb3b29450798",{"value":{"selectedCode":"            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n","suffix":"\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    _currentcolumn: &mut CurrentColumn,\n    _playliststate: &mut ListState,\n    _tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["95e62117-e96e-4333-974c-e463f9168c3a",{"value":{"selectedCode":"            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n","suffix":"\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    _currentcolumn: &mut CurrentColumn,\n    _playliststate: &mut ListState,\n    _tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["a375b53a-f40e-44f8-905d-40b36da1dad6",{"value":{"selectedCode":"            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            // Get tracks from the selected playlist or use an empty vector if no playlist is selected\n            let tracks_to_display = if let Some(playlist_idx) = backend.selection.selectedplaylist {\n                if playlist_idx < appstate.playlists.len() {\n                    &appstate.playlists[playlist_idx].tracks\n                } else {\n                    &Vec::new()\n                }\n            } else {\n                &Vec::new()\n            };\n            let trackscont = gettrackscont(tracks_to_display, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n\n","suffix":"\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    _currentcolumn: &mut CurrentColumn,\n    _playliststate: &mut ListState,\n    _tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n///\n/// # arguments\n/// * 'area' - the area to split up into individual areas\n///\n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar\n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["36bbf246-697d-4605-8737-26e8619f0ecf",{"value":{"selectedCode":"    pub selectedplaylist: Option<usize>,","prefix":"// models.rs\n// shared data structures for the music player app.\n\npub const MAXQUEUELENGTH: usize = 100;\npub const MPVSOCKET: &str = \"/tmp/mpvsocket\";\npub const SONGINFOPERCENT: u16 = 60;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum CurrentColumn {\n    Playlists,\n    Tracks,\n    Queue,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Track {\n    pub title: String,\n    pub artist: String,\n    pub url: String,\n}\n\nimpl Default for Track {\n    fn default() -> Self {\n        Self {\n            title: String::new(),\n            artist: String::new(),\n            url: String::new(),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Playlist {\n    pub name: String,\n    pub tracks: Vec<Track>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum RepeatMode {\n    None,\n    One,\n    All,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShuffleState {\n    pub shuffle: bool,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct RepeatState {\n    pub repeatmode: RepeatMode,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct QueueState {\n    pub queue: Vec<Track>,\n    pub history: Vec<Track>\n}\n\n#[derive(Clone, Debug)]\npub struct PlayerState {\n    pub isplaying: bool,\n    pub currenttime: u32, // in seconds\n    pub queuestate: QueueState,\n    pub repeatstate: RepeatState,\n    pub shufflestate: ShuffleState,\n}\n\n#[derive(Clone, Debug)]\npub struct SelectionState {\n    pub selectedcolumn: CurrentColumn,\n","suffix":"\n    pub selectedtrack: Option<usize>\n}\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\n#[derive(Clone, Debug)]\npub struct AppState {\n    pub playlists: Vec<Playlist>,\n    pub player: PlayerState,\n    pub popup: PopupState,\n}\n\n// UI helper functions\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n","path":"src/models.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["97fa8c49-c389-46f1-be96-16890c0ada63",{"value":{"selectedCode":"    pub playliststate: ratatui::widgets::ListState,","prefix":"// models.rs\n// shared data structures for the music player app.\n\npub const MAXQUEUELENGTH: usize = 100;\npub const MPVSOCKET: &str = \"/tmp/mpvsocket\";\npub const SONGINFOPERCENT: u16 = 60;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum CurrentColumn {\n    Playlists,\n    Tracks,\n    Queue,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Track {\n    pub title: String,\n    pub artist: String,\n    pub url: String,\n}\n\nimpl Default for Track {\n    fn default() -> Self {\n        Self {\n            title: String::new(),\n            artist: String::new(),\n            url: String::new(),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Playlist {\n    pub name: String,\n    pub tracks: Vec<Track>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum RepeatMode {\n    None,\n    One,\n    All,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShuffleState {\n    pub shuffle: bool,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct RepeatState {\n    pub repeatmode: RepeatMode,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct QueueState {\n    pub queue: Vec<Track>,\n    pub history: Vec<Track>\n}\n\n#[derive(Clone, Debug)]\npub struct PlayerState {\n    pub isplaying: bool,\n    pub currenttime: u32, // in seconds\n    pub queuestate: QueueState,\n    pub repeatstate: RepeatState,\n    pub shufflestate: ShuffleState,\n}\n\npub struct SelectionState {\n    pub selectedcolumn: CurrentColumn,\n","suffix":"\n    pub trackstate: ratatui::widgets::ListState,\n    pub queuestate: ratatui::widgets::ListState\n}\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\n#[derive(Clone, Debug)]\npub struct AppState {\n    pub playlists: Vec<Playlist>,\n    pub player: PlayerState,\n    pub popup: PopupState,\n}\n\n// UI helper functions\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n","path":"src/models.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["85b69a49-4907-4f3e-a94d-82beba130a91",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, backend.selection.selectedcolumn == CurrentColumn::Playlists);\n\n            // Get the selected playlist index from the ListState\n            let selected_playlist_idx = backend.selection.playliststate.selected();\n\n            // Get tracks from the selected playlist or use an empty vector if no playlist is selected\n            let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n                if playlist_idx < appstate.playlists.len() {\n                    &appstate.playlists[playlist_idx].tracks\n                } else {\n                    &Vec::new()\n                }\n            } else {\n                &Vec::new()\n            };\n\n            let trackscont = gettrackscont(tracks_to_display, backend.selection.selectedcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, backend.selection.selectedcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n\n            frame.render_stateful_widget(playlistscont, playlists, &mut backend.selection.playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut backend.selection.trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut backend.selection.queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n","suffix":"        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n///\n/// # arguments\n/// * 'area' - the area to split up into individual areas\n///\n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar\n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["f8cc2d02-6abe-4705-86ac-5b55d13e5b97",{"value":{"selectedCode":"","prefix":"// set.rs\n// backend write api\n\nuse super::Backend;\nuse crate::models::{CurrentColumn, MPVSOCKET, Playlist, RepeatMode, Track};\nuse anyhow::Result;\nuse rand::{seq::SliceRandom, rng};\nuse std::process::{Command, Stdio};\n\n// --- play/pause ---\npub fn playpause(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.isplaying {\n        pause(backend)?;\n    } else {\n        unpause(backend)?;\n    }\n    Ok(())\n}\n\nfn unpause(backend: &mut Backend) -> Result<()> {\n    let echooutput = Command::new(\"echo\")\n        .arg(r#\"{\"command\": [\"cycle\", \"pause\"]}\"#)\n        .stdout(Stdio::piped())\n        .spawn()?;\n    \n    if let Some(echoout) = echooutput.stdout {\n        let socatout = Command::new(\"socat\")\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout)) \n            .stdout(Stdio::null()) \n            .stderr(Stdio::piped()) \n            .output()?;\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to send pause command to mpv: {}\", stderr);\n        }\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n    }\n    backend.state.player.isplaying = true;\n    Ok(())\n}\n\nfn pause(backend: &mut Backend) -> Result<()> {\n    let echooutput = Command::new(\"echo\")\n        .arg(r#\"{\"command\": [\"cycle\", \"pause\"]}\"#)\n        .stdout(Stdio::piped())\n        .spawn()?;\n    \n    if let Some(echoout) = echooutput.stdout {\n        let socatout = Command::new(\"socat\")\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout)) \n            .stdout(Stdio::null()) \n            .stderr(Stdio::piped()) \n            .output()?;\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to send pause command to mpv: {}\", stderr);\n        }\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n    }\n    backend.state.player.isplaying = false;\n    Ok(())\n}\n\npub fn next(backend: &mut Backend) -> Result<()> {\n    if let Some(track) = backend.state.player.queuestate.queue.get(0).cloned() {\n        backend.state.player.queuestate.history.push(track);\n        backend.state.player.queuestate.queue.remove(0);\n        handlerepeat(backend)?;\n    }\n    Ok(())\n}\n\npub fn prev(backend: &mut Backend) -> Result<()> {\n    if let Some(track) = backend.state.player.queuestate.history.pop() {\n        backend.state.player.queuestate.queue.insert(0, track);\n    }\n    playsong(backend)?;\n    Ok(())\n}\n\npub fn toggleshuffle(backend: &mut Backend) {\n    backend.state.player.shufflestate.shuffle = !backend.state.player.shufflestate.shuffle;\n    shufflequeue(backend);\n}\n\nfn shufflequeue(backend: &mut Backend) {\n    if backend.state.player.shufflestate.shuffle && backend.state.player.queuestate.queue.len() > 1 {\n        if backend.state.player.shufflestate.originalqueue.is_empty() {\n            backend.state.player.shufflestate.originalqueue = backend.state.player.queuestate.queue.clone();\n        }\n        \n        let current = backend.state.player.queuestate.queue.remove(0);\n        \n        backend.state.player.queuestate.queue.shuffle(&mut rng());\n        \n        backend.state.player.queuestate.queue.insert(0, current);\n    } else if !backend.state.player.shufflestate.shuffle {\n        if !backend.state.player.shufflestate.originalqueue.is_empty() {\n            backend.state.player.queuestate.queue = backend.state.player.shufflestate.originalqueue.clone();\n            backend.state.player.shufflestate.originalqueue.clear();\n        }\n    }\n}\n\npub fn cyclerepeat(backend: &mut Backend) {\n    backend.state.player.repeatstate.repeatmode = match backend.state.player.repeatstate.repeatmode {\n        RepeatMode::None => RepeatMode::One,\n        RepeatMode::One => RepeatMode::All,\n        RepeatMode::All => RepeatMode::None\n    };\n}\n\nfn handlerepeat(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.queuestate.queue.is_empty() {\n        match backend.state.player.repeatstate.repeatmode {\n            RepeatMode::None => {\n                // do nothing\n            },\n            RepeatMode::One => {\n                if let Some(last_track) = backend.state.player.queuestate.history.last().cloned() {\n                    backend.state.player.queuestate.queue.insert(0, last_track);\n                    playsong(backend)?;\n                }\n            },\n            RepeatMode::All => {\n                let mut history = Vec::new();\n                std::mem::swap(&mut history, &mut backend.state.player.queuestate.history);\n                history.reverse();\n                backend.state.player.queuestate.queue = history;\n                if !backend.state.player.queuestate.queue.is_empty() {\n                    playsong(backend)?;\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\n// ---queue and playlist management ---\n\npub fn setqueue(backend: &mut Backend, tracks: Vec<Track>, clearhistory: bool) {\n    backend.state.player.queuestate.queue = tracks;\n    if clearhistory {\n        backend.state.player.queuestate.history.clear();\n    }\n}\n\npub fn addtoqueue(backend: &mut Backend, track: Track) {\n    backend.state.player.queuestate.queue.push(track);\n}\n\npub fn playnext(backend: &mut Backend, track: Track) {\n    backend.state.player.queuestate.queue.insert(0, track);\n}\n\npub fn playtrackfromqueue(backend: &mut Backend, index: usize) -> Result<()> {\n    if let Some(track) = backend.state.player.queuestate.queue.get(index).cloned() {\n        backend.state.player.queuestate.history.push(track);\n        backend.state.player.queuestate.queue.remove(index);\n    }\n    playsong(backend)?;\n    Ok(())\n}\n\npub fn addplaylist(backend: &mut Backend, playlist: Playlist) {\n    backend.state.playlists.push(playlist);\n}\n\npub fn selectplaylist(backend: &mut Backend, index: usize) -> Result<()> {\n    if index <= backend.state.playlists.len() {\n        backend.selection.selectedplaylist = Some(index);\n    } else if !backend.state.playlists.is_empty() { \n        backend.selection.selectedplaylist = Some(backend.state.playlists.len());\n    } else {\n        backend.selection.selectedplaylist = None;\n    }\n    Ok(())\n}\n\nfn playsong(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.queuestate.queue.is_empty() {\n        return Ok(());\n    }\n    \n    let currenturl = &backend.state.player.queuestate.queue[0].url;\n    \n    if let Some(mut process) = backend.mpvprocess.take() {\n        let _ = process.kill();\n    }\n    \n    backend.mpvprocess = Some(Command::new(\"mpv\")\n        .arg(currenturl)\n        .arg(\"--input-ipc-server=\".to_string() + MPVSOCKET)\n        .arg(\"--no-video\")\n        .arg(\"--no-terminal\")\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .spawn()?);\n    \n    backend.state.player.isplaying = true;\n    Ok(())\n}\n\n// --- navigation ---\n\npub fn nextcolumn(backend: &mut Backend) {\n    backend.selection.selectedcolumn = match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => CurrentColumn::Tracks,\n        CurrentColumn::Tracks => CurrentColumn::Queue,\n        CurrentColumn::Queue => CurrentColumn::Queue,\n    };\n}\n\npub fn prevcolumn(backend: &mut Backend) {\n    backend.selection.selectedcolumn = match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => CurrentColumn::Playlists,\n        CurrentColumn::Tracks => CurrentColumn::Playlists,\n        CurrentColumn::Queue => CurrentColumn::Tracks,\n    };\n}\n\npub fn nextrow(backend: &mut Backend) {\n    match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => {\n            let current = backend.selection.selectedplaylist.unwrap_or(0);\n            let numberofplaylists = backend.state.playlists.len();\n            let next = if current + 1 >= numberofplaylists {\n                numberofplaylists\n            } else {\n                current + 1\n            };\n            backend.selection.selectedplaylist = Some(next);\n        },\n        CurrentColumn::Tracks => {\n            if let Some(playlistidx) = backend.selection.selectedplaylist {\n                if let Some(playlist) = backend.state.playlists.get(playlistidx) {\n                    let current = backend.selection.selectedtrack.unwrap_or(0);\n                    let numberoftracks = playlist.tracks.len();\n                    let next = if current + 1 >= numberoftracks {\n                        numberoftracks\n                    } else {\n                        current + 1\n                    };\n                    backend.selection.selectedtrack = Some(next);\n                }\n            }\n        },\n        CurrentColumn::Queue => {\n            let current = backend.selection.selectedtrack.unwrap_or(0);\n            let queuelength = backend.state.player.queuestate.queue.len();\n            let next = if current >= queuelength - 1 {\n                queuelength\n            } else {\n                current + 1\n            };\n            backend.selection.selectedtrack = Some(next);\n        }\n    }\n}\n\npub fn prevrow(backend: &mut Backend) {\n    match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => {\n            let current = backend.selection.selectedplaylist.unwrap_or(0);\n            let next = if current <= 0 {\n                0\n            } else {\n                current - 1\n            };\n            backend.selection.selectedplaylist = Some(next);\n","suffix":"        },\n        CurrentColumn::Tracks => {\n            if let Some(playlistidx) = backend.selection.selectedplaylist {\n                if let Some(_) = backend.state.playlists.get(playlistidx) {\n                    let current = backend.selection.selectedtrack.unwrap_or(0);\n                    let next = if current <= 0 {\n                        0\n                    } else {\n                        current - 1\n                    };\n                    backend.selection.selectedtrack = Some(next);\n                }\n            }\n        },\n        CurrentColumn::Queue => {\n            let current = backend.selection.selectedtrack.unwrap_or(0);\n            let next = if current <= 0 {\n                0\n            } else {\n                current - 1\n            };\n            backend.selection.selectedtrack = Some(next);\n        }\n    }\n}\n","path":"src/backend/set.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["e5740ad9-216e-40e8-88d5-4580615f5382",{"value":{"selectedCode":"","prefix":"// backend/set.rs\n// handles setting state in the backend\n\nuse std::process::{Command, Stdio};\nuse anyhow::Result;\n\nuse crate::models::{CurrentColumn, MPVSOCKET, RepeatMode, Track, Playlist};\nuse super::Backend;\n\n// --- playback control ---\n\npub fn playpause(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.isplaying {\n        pause(backend)?;\n    } else {\n        play(backend)?;\n    }\n    Ok(())\n}\n\npub fn play(backend: &mut Backend) -> Result<()> {\n    if !backend.state.player.queuestate.queue.is_empty() {\n        backend.state.player.isplaying = true;\n        // TODO: send play command to mpv\n    }\n    Ok(())\n}\n\npub fn pause(backend: &mut Backend) -> Result<()> {\n    backend.state.player.isplaying = false;\n    // TODO: send pause command to mpv\n    Ok(())\n}\n\npub fn next(backend: &mut Backend) -> Result<()> {\n    if !backend.state.player.queuestate.queue.is_empty() {\n        // move current track to history\n        let current = backend.state.player.queuestate.queue.remove(0);\n        backend.state.player.queuestate.history.push(current);\n        \n        // play next track if available\n        if !backend.state.player.queuestate.queue.is_empty() {\n            playsong(backend)?;\n        } else {\n            // handle repeat mode\n            handlerepeat(backend)?;\n        }\n    }\n    Ok(())\n}\n\npub fn prev(backend: &mut Backend) -> Result<()> {\n    if !backend.state.player.queuestate.history.is_empty() {\n        // get the last track from history\n        let prev = backend.state.player.queuestate.history.pop().unwrap();\n        \n        // add current track back to the queue\n        if !backend.state.player.queuestate.queue.is_empty() {\n            let current = backend.state.player.queuestate.queue.remove(0);\n            backend.state.player.queuestate.queue.insert(0, prev);\n            backend.state.player.queuestate.queue.insert(1, current);\n        } else {\n            backend.state.player.queuestate.queue.insert(0, prev);\n        }\n        \n        // play the track\n        playsong(backend)?;\n    }\n    Ok(())\n}\n\n// --- playback settings ---\n\npub fn toggleshuffle(backend: &mut Backend) {\n    backend.state.player.shufflestate.shuffle = !backend.state.player.shufflestate.shuffle;\n    // TODO: implement shuffle logic\n}\n\npub fn cyclerepeat(backend: &mut Backend) {\n    backend.state.player.repeatstate.repeatmode = match backend.state.player.repeatstate.repeatmode {\n        RepeatMode::None => RepeatMode::One,\n        RepeatMode::One => RepeatMode::All,\n        RepeatMode::All => RepeatMode::None\n    };\n}\n\nfn handlerepeat(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.queuestate.queue.is_empty() {\n        match backend.state.player.repeatstate.repeatmode {\n            RepeatMode::None => {\n                // do nothing\n            },\n            RepeatMode::One => {\n                if let Some(last_track) = backend.state.player.queuestate.history.last().cloned() {\n                    backend.state.player.queuestate.queue.insert(0, last_track);\n                    playsong(backend)?;\n                }\n            },\n            RepeatMode::All => {\n                let mut history = Vec::new();\n                std::mem::swap(&mut history, &mut backend.state.player.queuestate.history);\n                history.reverse();\n                backend.state.player.queuestate.queue = history;\n                if !backend.state.player.queuestate.queue.is_empty() {\n                    playsong(backend)?;\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\n// ---queue and playlist management ---\n\npub fn setqueue(backend: &mut Backend, tracks: Vec<Track>, clearhistory: bool) {\n    backend.state.player.queuestate.queue = tracks;\n    if clearhistory {\n        backend.state.player.queuestate.history.clear();\n    }\n}\n\npub fn addtoqueue(backend: &mut Backend, track: Track) {\n    backend.state.player.queuestate.queue.push(track);\n}\n\npub fn playnext(backend: &mut Backend, track: Track) {\n    backend.state.player.queuestate.queue.insert(0, track);\n}\n\npub fn playtrackfromqueue(backend: &mut Backend, index: usize) -> Result<()> {\n    if let Some(track) = backend.state.player.queuestate.queue.get(index).cloned() {\n        backend.state.player.queuestate.history.push(track);\n        backend.state.player.queuestate.queue.remove(index);\n    }\n    playsong(backend)?;\n    Ok(())\n}\n\npub fn addplaylist(backend: &mut Backend, playlist: Playlist) {\n    backend.state.playlists.push(playlist);\n}\n\npub fn selectplaylist(backend: &mut Backend, index: usize) -> Result<()> {\n    if index < backend.state.playlists.len() {\n        backend.selection.playliststate.select(Some(index));\n    } else if !backend.state.playlists.is_empty() { \n        backend.selection.playliststate.select(Some(backend.state.playlists.len() - 1));\n    } else {\n        backend.selection.playliststate.select(None);\n    }\n    Ok(())\n}\n\nfn playsong(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.queuestate.queue.is_empty() {\n        return Ok(());\n    }\n    \n    let currenturl = &backend.state.player.queuestate.queue[0].url;\n    \n    if let Some(mut process) = backend.mpvprocess.take() {\n        let _ = process.kill();\n    }\n    \n    backend.mpvprocess = Some(Command::new(\"mpv\")\n        .arg(currenturl)\n        .arg(\"--input-ipc-server=\".to_string() + MPVSOCKET)\n        .arg(\"--no-video\")\n        .arg(\"--no-terminal\")\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .spawn()?);\n    \n    backend.state.player.isplaying = true;\n    Ok(())\n}\n\n// --- navigation ---\n\npub fn nextcolumn(backend: &mut Backend) {\n    backend.selection.selectedcolumn = match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => CurrentColumn::Tracks,\n        CurrentColumn::Tracks => CurrentColumn::Queue,\n        CurrentColumn::Queue => CurrentColumn::Queue,\n    };\n}\n\npub fn prevcolumn(backend: &mut Backend) {\n    backend.selection.selectedcolumn = match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => CurrentColumn::Playlists,\n        CurrentColumn::Tracks => CurrentColumn::Playlists,\n        CurrentColumn::Queue => CurrentColumn::Tracks,\n    };\n}\n\npub fn nextrow(backend: &mut Backend) {\n    match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => {\n            let playlists_len = backend.state.playlists.len();\n            if playlists_len > 0 {\n                let current = backend.selection.playliststate.selected().unwrap_or(0);\n                let next = if current + 1 >= playlists_len {\n                    playlists_len - 1\n                } else {\n                    current + 1\n                };\n                backend.selection.playliststate.select(Some(next));\n            }\n        },\n        CurrentColumn::Tracks => {\n            if let Some(playlist_idx) = backend.selection.playliststate.selected() {\n                if let Some(playlist) = backend.state.playlists.get(playlist_idx) {\n                    let tracks_len = playlist.tracks.len();\n                    if tracks_len > 0 {\n                        let current = backend.selection.trackstate.selected().unwrap_or(0);\n                        let next = if current + 1 >= tracks_len {\n                            tracks_len - 1\n                        } else {\n                            current + 1\n                        };\n                        backend.selection.trackstate.select(Some(next));\n                    }\n                }\n            }\n        },\n        CurrentColumn::Queue => {\n            let queue_len = backend.state.player.queuestate.queue.len();\n            if queue_len > 0 {\n                let current = backend.selection.queuestate.selected().unwrap_or(0);\n                let next = if current + 1 >= queue_len {\n                    queue_len - 1\n                } else {\n                    current + 1\n                };\n                backend.selection.queuestate.select(Some(next));\n            }\n        }\n    }\n}\n\npub fn prevrow(backend: &mut Backend) {\n    match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => {\n            if !backend.state.playlists.is_empty() {\n                let current = backend.selection.playliststate.selected().unwrap_or(0);\n                let next = if current == 0 {\n                    0\n                } else {\n                    current - 1\n                };\n                backend.selection.playliststate.select(Some(next));\n            }\n        },\n        CurrentColumn::Tracks => {\n            if let Some(playlist_idx) = backend.selection.playliststate.selected() {\n                if let Some(_) = backend.state.playlists.get(playlist_idx) {\n                    let current = backend.selection.trackstate.selected().unwrap_or(0);\n                    let next = if current == 0 {\n                        0\n                    } else {\n                        current - 1\n                    };\n                    backend.selection.trackstate.select(Some(next));\n                }\n            }\n        },\n        CurrentColumn::Queue => {\n            if !backend.state.player.queuestate.queue.is_empty() {\n                let current = backend.selection.queuestate.selected().unwrap_or(0);\n                let next = if current == 0 {\n                    0\n                } else {\n                    current - 1\n                };\n                backend.selection.queuestate.select(Some(next));\n            }\n        }\n    }\n}\n","suffix":"","path":"src/backend/set.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["bce9864c-099a-4319-8d2d-c9f94f1e3c55",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        \n        // Initialize ListState selections if needed\n        if backend.selection.playliststate.selected().is_none() && !appstate.playlists.is_empty() {\n            backend.selection.playliststate.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selected_playlist_idx = backend.selection.playliststate.selected();\n        \n        // Get tracks from the selected playlist\n        let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n","suffix":"            if playlist_idx < appstate.playlists.len() {\n                &appstate.playlists[playlist_idx].tracks\n            } else {\n                &Vec::new()\n            }\n        } else {\n            &Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        if backend.selection.trackstate.selected().is_none() && !tracks_to_display.is_empty() {\n            backend.selection.trackstate.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        if backend.selection.queuestate.selected().is_none() && !appstate.player.queuestate.queue.is_empty() {\n            backend.selection.queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, backend.selection.selectedcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(tracks_to_display, backend.selection.selectedcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, backend.selection.selectedcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            // Clone the ListState instances to avoid borrow issues\n            let mut playlist_state_clone = backend.selection.playliststate.clone();\n            let mut track_state_clone = backend.selection.trackstate.clone();\n            let mut queue_state_clone = backend.selection.queuestate.clone();\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playlist_state_clone);\n            frame.render_stateful_widget(trackscont, tracks, &mut track_state_clone);\n            frame.render_stateful_widget(queuecont, queue, &mut queue_state_clone);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            \n            // Update the original ListState instances\n            backend.selection.playliststate = playlist_state_clone;\n            backend.selection.trackstate = track_state_clone;\n            backend.selection.queuestate = queue_state_clone;\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["9ae6e598-db44-44be-a7dc-3fe77c25ea25",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // Get the app state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        {\n            let mut playlist_state = backend.selection.playliststate.clone();\n            if playlist_state.selected().is_none() && !appstate.playlists.is_empty() {\n                playlist_state.select(Some(0));\n            }\n            backend.selection.playliststate = playlist_state;\n        }\n        \n        // Get the selected playlist index\n        let selected_playlist_idx = backend.selection.playliststate.selected();\n        \n        // Get tracks from the selected playlist\n        let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n            if playlist_idx < appstate.playlists.len() {\n                &appstate.playlists[playlist_idx].tracks\n            } else {\n","suffix":"                &Vec::new()\n            }\n        } else {\n            &Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        {\n            let mut track_state = backend.selection.trackstate.clone();\n            if track_state.selected().is_none() && !tracks_to_display.is_empty() {\n                track_state.select(Some(0));\n            }\n            backend.selection.trackstate = track_state;\n        }\n        \n        // Initialize queue selection if needed\n        {\n            let mut queue_state = backend.selection.queuestate.clone();\n            if queue_state.selected().is_none() && !appstate.player.queuestate.queue.is_empty() {\n                queue_state.select(Some(0));\n            }\n            backend.selection.queuestate = queue_state;\n        }\n        \n        // Clone the selection state for use in the terminal.draw closure\n        let selected_column = backend.selection.selectedcolumn.clone();\n        let mut playlist_state_clone = backend.selection.playliststate.clone();\n        let mut track_state_clone = backend.selection.trackstate.clone();\n        let mut queue_state_clone = backend.selection.queuestate.clone();\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &appstate.player.isplaying);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selected_column == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(tracks_to_display, selected_column == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, selected_column == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playlist_state_clone);\n            frame.render_stateful_widget(trackscont, tracks, &mut track_state_clone);\n            frame.render_stateful_widget(queuecont, queue, &mut queue_state_clone);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playlist_state_clone;\n        backend.selection.trackstate = track_state_clone;\n        backend.selection.queuestate = queue_state_clone;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["05af3618-0823-45b5-bd04-7332efea319c",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // Get the app state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        {\n            let mut playlist_state = backend.selection.playliststate.clone();\n            if playlist_state.selected().is_none() && !appstate.playlists.is_empty() {\n                playlist_state.select(Some(0));\n            }\n            backend.selection.playliststate = playlist_state;\n        }\n        \n","suffix":"        // Get the selected playlist index\n        let selected_playlist_idx = backend.selection.playliststate.selected();\n        \n        // Get tracks from the selected playlist\n        let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n            if playlist_idx < appstate.playlists.len() {\n                &appstate.playlists[playlist_idx].tracks\n            } else {\n                &Vec::new()\n            }\n        } else {\n            &Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        {\n            let mut track_state = backend.selection.trackstate.clone();\n            if track_state.selected().is_none() && !tracks_to_display.is_empty() {\n                track_state.select(Some(0));\n            }\n            backend.selection.trackstate = track_state;\n        }\n        \n        // Initialize queue selection if needed\n        {\n            let mut queue_state = backend.selection.queuestate.clone();\n            if queue_state.selected().is_none() && !appstate.player.queuestate.queue.is_empty() {\n                queue_state.select(Some(0));\n            }\n            backend.selection.queuestate = queue_state;\n        }\n        \n        // Clone the selection state for use in the terminal.draw closure\n        let selected_column = backend.selection.selectedcolumn.clone();\n        let mut playlist_state_clone = backend.selection.playliststate.clone();\n        let mut track_state_clone = backend.selection.trackstate.clone();\n        let mut queue_state_clone = backend.selection.queuestate.clone();\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &appstate.player.isplaying);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selected_column == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(tracks_to_display, selected_column == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, selected_column == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playlist_state_clone);\n            frame.render_stateful_widget(trackscont, tracks, &mut track_state_clone);\n            frame.render_stateful_widget(queuecont, queue, &mut queue_state_clone);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playlist_state_clone;\n        backend.selection.trackstate = track_state_clone;\n        backend.selection.queuestate = queue_state_clone;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["d5a9b0cb-698a-4a98-bba6-f111c8e72c4b",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // Get the app state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let is_playing = appstate.player.isplaying.clone();\n        let selected_column = backend.selection.selectedcolumn.clone();\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        // We need to clone the state to avoid borrow issues\n        let mut playlist_state = backend.selection.playliststate.clone();\n        if playlist_state.selected().is_none() && !appstate.playlists.is_empty() {\n            playlist_state.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selected_playlist_idx = playlist_state.selected();\n        \n        // Get tracks from the selected playlist\n        let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n            if playlist_idx < appstate.playlists.len() {\n                appstate.playlists[playlist_idx].tracks.clone()\n            } else {\n                Vec::new()\n            }\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut track_state = backend.selection.trackstate.clone();\n        if track_state.selected().is_none() && !tracks_to_display.is_empty() {\n            track_state.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queue_state = backend.selection.queuestate.clone();\n        if queue_state.selected().is_none() && !appstate.player.queuestate.queue.is_empty() {\n            queue_state.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &is_playing);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selected_column == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&tracks_to_display, selected_column == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, selected_column == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&is_playing);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playlist_state);\n            frame.render_stateful_widget(trackscont, tracks, &mut track_state);\n            frame.render_stateful_widget(queuecont, queue, &mut queue_state);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playlist_state;\n        backend.selection.trackstate = track_state;\n        backend.selection.queuestate = queue_state;\n\n","suffix":"        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["44ffc498-ffbf-4b8b-bb10-3eec399a39ee",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // Get the app state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let is_playing = appstate.player.isplaying.clone();\n        let selected_column = backend.selection.selectedcolumn.clone();\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        // We need to clone the state to avoid borrow issues\n        let mut playlist_state = backend.selection.playliststate.clone();\n        if playlist_state.selected().is_none() && !appstate.playlists.is_empty() {\n            playlist_state.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selected_playlist_idx = playlist_state.selected();\n        \n        // Get tracks from the selected playlist\n        let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n            if playlist_idx < appstate.playlists.len() {\n                appstate.playlists[playlist_idx].tracks.clone()\n            } else {\n                Vec::new()\n            }\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut track_state = backend.selection.trackstate.clone();\n        if track_state.selected().is_none() && !tracks_to_display.is_empty() {\n            track_state.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queue_state = backend.selection.queuestate.clone();\n        if queue_state.selected().is_none() && !appstate.player.queuestate.queue.is_empty() {\n            queue_state.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &is_playing);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selected_column == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&tracks_to_display, selected_column == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, selected_column == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&is_playing);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playlist_state);\n            frame.render_stateful_widget(trackscont, tracks, &mut track_state);\n            frame.render_stateful_widget(queuecont, queue, &mut queue_state);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n","suffix":"            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playlist_state;\n        backend.selection.trackstate = track_state;\n        backend.selection.queuestate = queue_state;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["a1d7ce9d-df64-4e7b-94da-9bb39a72380a",{"value":{"selectedCode":"","prefix":"// main.rs\n// entry point\n\nmod backend;\nmod frontend;\nmod models;\n\nuse std::io::{self, Write};\n\nuse anyhow::Result;\nuse backend::Backend;\nuse frontend::runfrontend;\n\nconst DEBUG: bool = true;\n\nfn main() -> Result<()> {\n    if DEBUG {\n        println!(\"--- debug CLI ---\");\n        println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n    \n        // initialize the backend\n        let mut backend = Backend::new();\n\n","suffix":"        // dummy track\n        let testtrack = models::Track { title: \"losing interest\".to_string(), artist: \"adore\".to_string(), url: \"https://www.youtube.com/watch?v=HtR4PkPJiBk\".to_string() };\n        let testtrack1 = models::Track { title: \"losing interest but again\".to_string(), artist: \"adore\".to_string(), url: \"https://www.youtube.com/watch?v=HtR4PkPJiBk\".to_string() };\n        backend::set::addplaylist(&mut backend, models::Playlist { name: \"sigma 1\".to_string(), tracks: vec![testtrack.clone()] });\n        backend::set::addplaylist(&mut backend, models::Playlist { name: \"sigma 2\".to_string(), tracks: vec![testtrack1.clone()] });\n        backend::set::addtoqueue(&mut backend, testtrack);\n        backend::set::addtoqueue(&mut backend, testtrack1);\n    \n        let mut inputbuffer = String::new();\n    \n        // main command loop\n        loop {\n            print!(\"> \"); // prompt\n            io::stdout().flush()?;\n    \n            // clear the buffer and read the next line\n            inputbuffer.clear();\n            if io::stdin().read_line(&mut inputbuffer)? == 0 {\n                // handle eof\n                println!(\"exiting...\");\n                break;\n            }\n    \n            // parse the input\n            let parts: Vec<&str> = inputbuffer.trim().split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n    \n            let command = parts[0];\n            let args = &parts[1..];\n    \n            // execute commands\n            match command {\n                \"play\" => {\n                    if let Err(e) = backend::set::playpause(&mut backend, ) {\n                        println!(\"error playing: {}\", e);\n                    } else {\n                        println!(\"play command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate(&backend));\n                }\n                \"pause\" => {\n                    if let Err(e) = backend::set::playpause(&mut backend, ) {\n                        println!(\"error pausing: {}\", e);\n                    } else {\n                        println!(\"pause command sent.\");\n                    }\n                    println!(\"current playing state: {}\", backend::get::playingstate(&backend));\n                }\n                \"next\" => {\n                    if let Err(e) = backend::set::next(&mut backend, ) {\n                        println!(\"error going to next track: {}\", e);\n                    } else {\n                        println!(\"next command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong(&backend));\n                }\n                \"prev\" => {\n                    if let Err(e) = backend::set::prev(&mut backend, ) {\n                        println!(\"error going to previous track: {}\", e);\n                    } else {\n                        println!(\"prev command sent.\");\n                    }\n                    println!(\"current track: {:?}\", backend::get::currentsong(&backend));\n                }\n                \"state\" => {\n                    // print the current backend state\n                    println!(\"{:#?}\", backend::get::state(&backend));\n                }\n                \"add\" => {\n                    if args.len() == 1 {\n                        let url = args[0].to_string();\n                        // create a dummy track for testing\n                        let track = models::Track {\n                            title: format!(\"track at {}\", url),\n                            artist: \"unknown\".to_string(),\n                            url,\n                        };\n                        backend::set::addtoqueue(&mut backend, track);\n                        println!(\"added track to queue.\");\n                    } else {\n                        println!(\"usage: add <url>\");\n                    }\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state(&backend).player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"queue\" => {\n                    println!(\"current queue:\");\n                    for (i, track) in backend::get::state(&backend).player.queuestate.queue.iter().enumerate() {\n                        println!(\"  {}: {} - {}\", i, track.artist, track.title);\n                    }\n                }\n                \"exit\" | \"quit\" | \"q\" => {\n                    println!(\"exiting...\");\n                    break;\n                }\n                \"help\" => {\n                    println!(\"available commands: play, pause, next, prev, state, add <url>, queue, exit, help\");\n                }\n                _ => {\n                    println!(\"unknown command: {}\", command);\n                }\n            }\n        }\n    } else {\n        // initialize backend\n        let mut backend = Backend::new();\n\n        // start frontend, passing the backend for interaction\n        runfrontend(backend)?;\n    } \n\n    Ok(())\n}\n","path":"src/main.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["79a9c7c9-f125-4acc-9668-45eb4a381d05",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // get the app state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = appstate.player.isplaying.clone();\n        let selectedcolumn = backend.selection.selectedcolumn.clone();\n        \n        let mut playliststate = backend.selection.playliststate.clone();\n        if playliststate.selected().is_none() && !appstate.playlists.is_empty() {\n            playliststate.select(Some(0));\n        }\n        \n        // get the selected playlist index\n        let selectedplaylistidx = playliststate.selected();\n        \n        // get tracks from the selected playlist\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            if playlistidx < appstate.playlists.len() {\n                appstate.playlists[playlistidx].tracks.clone()\n            } else {\n                Vec::new()\n            }\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !appstate.player.queuestate.queue.is_empty() {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n","suffix":"            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selectedcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, selectedcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playliststate;\n        backend.selection.trackstate = trackstate;\n        backend.selection.queuestate = queuestate;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["67eabd0c-4508-446f-b4e6-fb502d051b9e",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // Get the app state using the backend's get API\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let is_playing = *backend::get::playingstate(&backend);\n        let selected_column = backend.selection.selectedcolumn.clone();\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        let mut playlist_state = backend.selection.playliststate.clone();\n        if playlist_state.selected().is_none() && !backend::get::playlists_empty(&backend) {\n            playlist_state.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selected_playlist_idx = playlist_state.selected();\n        \n        // Get tracks from the selected playlist using the backend's get API\n        let tracks_to_display = if let Some(playlist_idx) = selected_playlist_idx {\n            backend::get::playlist_tracks(&backend, playlist_idx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut track_state = backend.selection.trackstate.clone();\n        if track_state.selected().is_none() && !tracks_to_display.is_empty() {\n            track_state.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queue_state = backend.selection.queuestate.clone();\n        if queue_state.selected().is_none() && !backend::get::queue_empty(&backend) {\n            queue_state.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &is_playing);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selected_column == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&tracks_to_display, selected_column == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selected_column == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&is_playing);\n            \n            // Get the current song info using the backend's get API\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n                \n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playlist_state);\n            frame.render_stateful_widget(trackscont, tracks, &mut track_state);\n            frame.render_stateful_widget(queuecont, queue, &mut queue_state);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playlist_state;\n        backend.selection.trackstate = track_state;\n        backend.selection.queuestate = queue_state;\n\n","suffix":"        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["83fdbef9-5af2-4d34-8fe6-c81c0dc8a37a",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend.selection.selectedcolumn.clone();\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        let mut playliststate = backend.selection.playliststate.clone();\n        if playliststate.selected().is_none() && !backend::get::playlists_empty(&backend) {\n            playliststate.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selectedplaylistidx = playliststate.selected();\n        \n        // Get tracks from the selected playlist using the backend's get API\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlist_tracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n","suffix":"        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selectedcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            \n            // Get the current song info using the backend's get API\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n                \n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playliststate;\n        backend.selection.trackstate = trackstate;\n        backend.selection.queuestate = queuestate;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["4af152d3-4b34-40da-9252-7b1f3de2f67d",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend.selection.selectedcolumn.clone();\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        let mut playliststate = backend.selection.playliststate.clone();\n        if playliststate.selected().is_none() && !backend::get::playlists_empty(&backend) {\n            playliststate.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selectedplaylistidx = playliststate.selected();\n        \n        // Get tracks from the selected playlist using the backend's get API\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlist_tracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut trackstate = backend.selection.trackstate.clone();\n","suffix":"        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(&appstate.playlists, selectedcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            \n            // Get the current song info using the backend's get API\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n                \n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playliststate;\n        backend.selection.trackstate = trackstate;\n        backend.selection.queuestate = queuestate;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["cc429a97-9003-4aac-b625-df914ddcc04d",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // Get the app state using the backend's get API\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend.selection.selectedcolumn.clone();\n        \n        // Initialize selections if needed (do this outside the terminal.draw closure)\n        let mut playliststate = backend.selection.playliststate.clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n        \n        // Get the selected playlist index\n        let selectedplaylistidx = playliststate.selected();\n        \n        // Get tracks from the selected playlist using the backend's get API\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlist_tracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        // Initialize track selection if needed\n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        // Initialize queue selection if needed\n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            \n            // Get the current song info using the backend's get API\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n                \n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n        \n        // Update the selection state with the values from the clones\n        backend.selection.playliststate = playliststate;\n        backend.selection.trackstate = trackstate;\n        backend.selection.queuestate = queuestate;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n","suffix":"        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["c7a70dcb-00e2-4fb1-9ce2-ccc6c5f1024f",{"value":{"selectedCode":"        let popupcont = Paragraph::from(app.popup.message.iter().map(|l| Line::from(l.clone())))","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend, app: &mut App) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(area, 40, 10);\n","suffix":"\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":1}}],["1215de2b-267a-4d7e-a030-ff8073a8beef",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut app, &mut running, key.code, &app.popup.onscreen)?;\n                }\n            }\n        }\n","suffix":"\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: &bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":1}}],["e18a0066-f780-45aa-807c-3034caf3726c",{"value":{"selectedCode":"        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut app, &mut running, key.code, &app.popup.onscreen)?;\n                }\n            }","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n","suffix":"\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: &bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":1}}],["07adcdaa-b6fe-4646-8dbc-e5a052552474",{"value":{"selectedCode":"        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut app, &mut running, key.code, &app.popup.onscreen)?;\n                }\n            }","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n","suffix":"\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: &bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":1}}],["ac73b756-2192-42ce-abe3-3f2c7886bb8e",{"value":{"selectedCode":"                    if let Err(e) = handleinput(&mut backend, &mut app, &mut running, key.code, &app.popup.onscreen) {","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n","suffix":"\n                        newpopup(&mut app, \n                            \"Error\".to_string(),\n                            vec![format!(\"Input error: {}\", e)],\n                            true\n                        );\n                    }\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: &bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["64320c09-1e65-42a4-894e-871a076a5b80",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    if let Err(e) = handleinput(&mut backend, &mut app, &mut running, key.code, app.popup.onscreen) {\n                        newpopup(&mut app, \n                            \"Error\".to_string(),\n                            vec![format!(\"Input error: {}\", e)],\n","suffix":"                            true\n                        );\n                    }\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: &bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["03f286b9-b9ce-4b2a-815a-f183cd145e92",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    if let Err(e) = handleinput(&mut backend, &mut app, &mut running, key.code, app.popup.onscreen) {\n                        newpopup(&mut app, \n                            \"Error\".to_string(),\n","suffix":"                            vec![format!(\"Input error: {}\", e)],\n                            true\n                        );\n                    }\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["8c6fcd73-99c2-4d89-8e1f-76d5f6f4770e",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        let popupopen = app.popup.onscreen;\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    if let Err(e) = handleinput(&mut backend, &mut app, &mut running, key.code, popupopen) {\n                        newpopup(&mut app, \n                            \"Error\".to_string(),\n                            vec![format!(\"Input error: {}\", e)],\n                            true\n                        );\n                    }\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n","suffix":"        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer  v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on \")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}]]