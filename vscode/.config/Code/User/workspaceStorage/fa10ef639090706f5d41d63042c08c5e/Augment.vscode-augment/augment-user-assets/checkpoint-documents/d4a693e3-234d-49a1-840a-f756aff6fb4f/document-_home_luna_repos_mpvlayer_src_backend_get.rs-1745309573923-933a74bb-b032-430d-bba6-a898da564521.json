{"path":{"rootPath":"/home/luna/repos/mpvlayer","relPath":"src/backend/get.rs"},"originalCode":"// get.rs\n// backend read api\n\nuse super::Backend;\nuse crate::models::{AppState, PlayerState, Playlist, RepeatMode, Track, MPVSOCKET};\nuse anyhow::Result;\nuse std::process::{Command, Stdio};\nuse serde_json;\n\n// --- state access functions (for frontend to read) ---\npub fn state(backend: &Backend) -> &AppState {\n    &backend.state\n}\n\npub fn playingstate(backend: &Backend) -> &bool {\n    &backend.state.player.isplaying\n}\n\npub fn playerstate(backend: &Backend) -> &PlayerState {\n    &backend.state.player\n}\n\npub fn playlists(backend: &Backend) -> &Vec<Playlist> {\n    &backend.state.playlists\n}\n\npub fn repeatstate(backend: &Backend) -> &RepeatMode {\n    &backend.state.player.repeatstate.repeatmode\n}\n\npub fn shufflestate(backend: &Backend) -> &bool {\n    &backend.state.player.shufflestate.shuffle\n}\n\npub fn elapsedduration() -> Result<u32> {\n    // Add timeout for socket operations\n    let timeout = std::time::Duration::from_secs(2);\n\n    // unique request ID for this request\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"time-pos\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-T\")\n            .arg(timeout.as_secs().to_string())\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to get playback position from mpv: {}\", stderr);\n            return Ok(0);\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }\n        }\n\n        // return 0 if we couldn't parse the position\n        return Ok(0);\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn totalduration() -> Result<u32> {\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"duration\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to get total duration from mpv: {}\", stderr);\n            return Ok(0);\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }\n        }\n\n        // return 0 if we couldn't parse the position\n        return Ok(0);\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn currentsong(backend: &Backend) -> Option<&Track> {\n    backend.state.player.queuestate.queue.get(0)\n}\n\npub fn queue(backend: &Backend) -> &Vec<Track> {\n    &backend.state.player.queuestate.queue\n}\n","modifiedCode":"// get.rs\n// backend read api\n\nuse super::Backend;\nuse crate::models::{AppState, PlayerState, Playlist, RepeatMode, Track, MPVSOCKET};\nuse anyhow::Result;\nuse std::process::{Command, Stdio};\nuse serde_json;\n\n// --- state access functions (for frontend to read) ---\npub fn state(backend: &Backend) -> &AppState {\n    &backend.state\n}\n\npub fn playingstate(backend: &Backend) -> &bool {\n    &backend.state.player.isplaying\n}\n\npub fn playerstate(backend: &Backend) -> &PlayerState {\n    &backend.state.player\n}\n\npub fn playlists(backend: &Backend) -> &Vec<Playlist> {\n    &backend.state.playlists\n}\n\npub fn repeatstate(backend: &Backend) -> &RepeatMode {\n    &backend.state.player.repeatstate.repeatmode\n}\n\npub fn shufflestate(backend: &Backend) -> &bool {\n    &backend.state.player.shufflestate.shuffle\n}\n\npub fn elapsedduration() -> Result<u32> {\n    // Add timeout for socket operations\n    let timeout = std::time::Duration::from_secs(2);\n\n    // unique request ID for this request\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"time-pos\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-T\")\n            .arg(timeout.as_secs().to_string())\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to get playback position from mpv: {}\", stderr);\n            return Ok(0);\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }\n        }\n\n        // return 0 if we couldn't parse the position\n        return Ok(0);\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn totalduration() -> Result<u32> {\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"duration\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to get total duration from mpv: {}\", stderr);\n            return Ok(0);\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }\n        }\n\n        // return 0 if we couldn't parse the position\n        return Ok(0);\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn currentsong(backend: &Backend) -> Option<&Track> {\n    backend.state.player.queuestate.queue.get(0)\n}\n\npub fn queue(backend: &Backend) -> &Vec<Track> {\n    &backend.state.player.queuestate.queue\n}\n\npub fn playlist_tracks(backend: &Backend, playlist_idx: usize) -> Option<Vec<Track>> {\n    if playlist_idx < backend.state.playlists.len() {\n        Some(backend.state.playlists[playlist_idx].tracks.clone())\n    } else {\n        None\n    }\n}\n\npub fn selected_column(backend: &Backend) -> CurrentColumn {\n    backend.selection.selectedcolumn.clone()\n}\n\npub fn playlists_empty(backend: &Backend) -> bool {\n    backend.state.playlists.is_empty()\n}\n\npub fn queue_empty(backend: &Backend) -> bool {\n    backend.state.player.queuestate.queue.is_empty()\n}\n"}