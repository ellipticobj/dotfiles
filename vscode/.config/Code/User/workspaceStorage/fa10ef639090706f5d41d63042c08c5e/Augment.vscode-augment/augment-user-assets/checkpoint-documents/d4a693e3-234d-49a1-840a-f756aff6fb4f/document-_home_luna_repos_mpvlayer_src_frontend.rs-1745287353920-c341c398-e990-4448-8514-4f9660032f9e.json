{"path":{"rootPath":"/home/luna/repos/mpvlayer","relPath":"src/frontend.rs"},"originalCode":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.size();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    currentcolumn: &mut CurrentColumn,\n    playliststate: &mut ListState,\n    tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n///\n/// # arguments\n/// * 'area' - the area to split up into individual areas\n///\n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar\n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer ── v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n","modifiedCode":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    widgets::ListState,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, getsonginfocont};\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    // This is separate from backend state; it's just for UI-specific things\n    let mut playliststate = ListState::default();\n    let mut tracksstate = ListState::default();\n    let mut queuestate = ListState::default();\n    let mut currentcolumn = CurrentColumn::Playlists;\n    let mut running = true;\n    let version = String::from(\"0.0.1\");\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        // draw the UI based on backend state\n        let appstate = backend::get::state(&backend);\n        let elapsed = backend::get::elapsedduration()?;\n        let total = backend::get::totalduration()?;\n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, backend::get::playingstate(&backend));\n\n            let playlistscont = getplaylistscont(&appstate.playlists, currentcolumn == CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&appstate.tracks, currentcolumn == CurrentColumn::Tracks);\n            let queuecont = getqueuecont(&appstate.player.queuestate.queue, currentcolumn == CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&appstate.player.isplaying);\n            let songinfocont = appstate.player.queuestate.queue.first()\n                .map(|track| getsonginfocont(track, appstate.player.shufflestate.shuffle, appstate.player.repeatstate.repeatmode.clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None)); // Assuming Track implements Default\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(&version);\n            \n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut tracksstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n            // TODO: draw screen\n        })?;\n\n        // Handle input\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    handleinput(&mut backend, &mut running, &mut currentcolumn, &mut playliststate, &mut tracksstate, &mut queuestate, key.code)?;\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    running: &mut bool,\n    _currentcolumn: &mut CurrentColumn,\n    _playliststate: &mut ListState,\n    _tracksstate: &mut ListState,\n    _queuestate: &mut ListState,\n    key: KeyCode,\n) -> Result<()> {\n    // Handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => {\n            // TODO: restart song when < 10 secs\n            backend::set::prev(backend)?\n        },\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if isplaying.to_owned() {\n        String::from(\"[<<] [play] [>>]\")\n    } else {\n        String::from(\"[<<] [pause] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::White)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer ── v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n"}