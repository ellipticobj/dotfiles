{"path":{"rootPath":"/home/luna/repos/mpvlayer","relPath":"src/models.rs"},"originalCode":"// models.rs\n// shared data structures for the music player app.\n\npub const MAXQUEUELENGTH: usize = 100;\npub const MPVSOCKET: &str = \"/tmp/mpvsocket\";\npub const SONGINFOPERCENT: u16 = 60;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum CurrentColumn {\n    Playlists,\n    Tracks,\n    Queue,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Track {\n    pub title: String,\n    pub artist: String,\n    pub url: String,\n}\n\nimpl Default for Track {\n    fn default() -> Self {\n        Self {\n            title: String::new(),\n            artist: String::new(),\n            url: String::new(),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Playlist {\n    pub name: String,\n    pub tracks: Vec<Track>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum RepeatMode {\n    None,\n    One,\n    All,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShuffleState {\n    pub shuffle: bool,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct RepeatState {\n    pub repeatmode: RepeatMode,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct QueueState {\n    pub queue: Vec<Track>,\n    pub history: Vec<Track>\n}\n\n#[derive(Clone, Debug)]\npub struct PlayerState {\n    pub isplaying: bool,\n    pub currenttime: u32, // in seconds\n    pub queuestate: QueueState,\n    pub repeatstate: RepeatState,\n    pub shufflestate: ShuffleState,\n}\n\n#[derive(Clone, Debug)]\npub struct SelectionState {\n    pub selectedcolumn: CurrentColumn,\n    pub selectedplaylist: Option<usize>,\n    pub selectedtrack: Option<usize>\n}\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\n#[derive(Clone, Debug)]\npub struct AppState {\n    pub playlists: Vec<Playlist>,\n    pub tracks: Vec<Track>,  // Adding tracks field for UI display\n    pub player: PlayerState,\n    pub popup: PopupState,\n}\n\n// UI helper functions\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on ─\")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"──\")\n}\n\n","modifiedCode":"// models.rs\n// shared data structures for the music player app.\n\npub const MAXQUEUELENGTH: usize = 100;\npub const MPVSOCKET: &str = \"/tmp/mpvsocket\";\npub const SONGINFOPERCENT: u16 = 60;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum CurrentColumn {\n    Playlists,\n    Tracks,\n    Queue,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Track {\n    pub title: String,\n    pub artist: String,\n    pub url: String,\n}\n\nimpl Default for Track {\n    fn default() -> Self {\n        Self {\n            title: String::new(),\n            artist: String::new(),\n            url: String::new(),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Playlist {\n    pub name: String,\n    pub tracks: Vec<Track>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum RepeatMode {\n    None,\n    One,\n    All,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShuffleState {\n    pub shuffle: bool,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct RepeatState {\n    pub repeatmode: RepeatMode,\n    pub originalqueue: Vec<Track>\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct QueueState {\n    pub queue: Vec<Track>,\n    pub history: Vec<Track>\n}\n\n#[derive(Clone, Debug)]\npub struct PlayerState {\n    pub isplaying: bool,\n    pub currenttime: u32, // in seconds\n    pub queuestate: QueueState,\n    pub repeatstate: RepeatState,\n    pub shufflestate: ShuffleState,\n}\n\n#[derive(Clone, Debug)]\npub struct SelectionState {\n    pub selectedcolumn: CurrentColumn,\n    pub selectedplaylist: Option<usize>,\n    pub selectedtrack: Option<usize>\n}\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\n#[derive(Clone, Debug)]\npub struct AppState {\n    pub playlists: Vec<Playlist>,\n    pub player: PlayerState,\n    pub popup: PopupState,\n}\n\n// UI helper functions\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on ─\")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"──\")\n}\n\n"}