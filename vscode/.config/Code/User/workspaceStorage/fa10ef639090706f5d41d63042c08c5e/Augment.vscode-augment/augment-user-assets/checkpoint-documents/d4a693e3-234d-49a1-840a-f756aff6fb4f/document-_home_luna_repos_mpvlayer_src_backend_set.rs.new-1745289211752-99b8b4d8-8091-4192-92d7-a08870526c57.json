{"path":{"rootPath":"/home/luna/repos/mpvlayer","relPath":"src/backend/set.rs.new"},"modifiedCode":"// backend/set.rs\n// handles setting state in the backend\n\nuse std::process::{Command, Stdio};\nuse anyhow::Result;\n\nuse crate::models::{CurrentColumn, MPVSOCKET, RepeatMode, Track, Playlist};\nuse super::Backend;\n\n// --- playback control ---\n\npub fn playpause(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.isplaying {\n        pause(backend)?;\n    } else {\n        play(backend)?;\n    }\n    Ok(())\n}\n\npub fn play(backend: &mut Backend) -> Result<()> {\n    if !backend.state.player.queuestate.queue.is_empty() {\n        backend.state.player.isplaying = true;\n        // TODO: send play command to mpv\n    }\n    Ok(())\n}\n\npub fn pause(backend: &mut Backend) -> Result<()> {\n    backend.state.player.isplaying = false;\n    // TODO: send pause command to mpv\n    Ok(())\n}\n\npub fn next(backend: &mut Backend) -> Result<()> {\n    if !backend.state.player.queuestate.queue.is_empty() {\n        // move current track to history\n        let current = backend.state.player.queuestate.queue.remove(0);\n        backend.state.player.queuestate.history.push(current);\n        \n        // play next track if available\n        if !backend.state.player.queuestate.queue.is_empty() {\n            playsong(backend)?;\n        } else {\n            // handle repeat mode\n            handlerepeat(backend)?;\n        }\n    }\n    Ok(())\n}\n\npub fn prev(backend: &mut Backend) -> Result<()> {\n    if !backend.state.player.queuestate.history.is_empty() {\n        // get the last track from history\n        let prev = backend.state.player.queuestate.history.pop().unwrap();\n        \n        // add current track back to the queue\n        if !backend.state.player.queuestate.queue.is_empty() {\n            let current = backend.state.player.queuestate.queue.remove(0);\n            backend.state.player.queuestate.queue.insert(0, prev);\n            backend.state.player.queuestate.queue.insert(1, current);\n        } else {\n            backend.state.player.queuestate.queue.insert(0, prev);\n        }\n        \n        // play the track\n        playsong(backend)?;\n    }\n    Ok(())\n}\n\n// --- playback settings ---\n\npub fn toggleshuffle(backend: &mut Backend) {\n    backend.state.player.shufflestate.shuffle = !backend.state.player.shufflestate.shuffle;\n    // TODO: implement shuffle logic\n}\n\npub fn cyclerepeat(backend: &mut Backend) {\n    backend.state.player.repeatstate.repeatmode = match backend.state.player.repeatstate.repeatmode {\n        RepeatMode::None => RepeatMode::One,\n        RepeatMode::One => RepeatMode::All,\n        RepeatMode::All => RepeatMode::None\n    };\n}\n\nfn handlerepeat(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.queuestate.queue.is_empty() {\n        match backend.state.player.repeatstate.repeatmode {\n            RepeatMode::None => {\n                // do nothing\n            },\n            RepeatMode::One => {\n                if let Some(last_track) = backend.state.player.queuestate.history.last().cloned() {\n                    backend.state.player.queuestate.queue.insert(0, last_track);\n                    playsong(backend)?;\n                }\n            },\n            RepeatMode::All => {\n                let mut history = Vec::new();\n                std::mem::swap(&mut history, &mut backend.state.player.queuestate.history);\n                history.reverse();\n                backend.state.player.queuestate.queue = history;\n                if !backend.state.player.queuestate.queue.is_empty() {\n                    playsong(backend)?;\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\n// ---queue and playlist management ---\n\npub fn setqueue(backend: &mut Backend, tracks: Vec<Track>, clearhistory: bool) {\n    backend.state.player.queuestate.queue = tracks;\n    if clearhistory {\n        backend.state.player.queuestate.history.clear();\n    }\n}\n\npub fn addtoqueue(backend: &mut Backend, track: Track) {\n    backend.state.player.queuestate.queue.push(track);\n}\n\npub fn playnext(backend: &mut Backend, track: Track) {\n    backend.state.player.queuestate.queue.insert(0, track);\n}\n\npub fn playtrackfromqueue(backend: &mut Backend, index: usize) -> Result<()> {\n    if let Some(track) = backend.state.player.queuestate.queue.get(index).cloned() {\n        backend.state.player.queuestate.history.push(track);\n        backend.state.player.queuestate.queue.remove(index);\n    }\n    playsong(backend)?;\n    Ok(())\n}\n\npub fn addplaylist(backend: &mut Backend, playlist: Playlist) {\n    backend.state.playlists.push(playlist);\n}\n\npub fn selectplaylist(backend: &mut Backend, index: usize) -> Result<()> {\n    if index < backend.state.playlists.len() {\n        backend.selection.playliststate.select(Some(index));\n    } else if !backend.state.playlists.is_empty() { \n        backend.selection.playliststate.select(Some(backend.state.playlists.len() - 1));\n    } else {\n        backend.selection.playliststate.select(None);\n    }\n    Ok(())\n}\n\nfn playsong(backend: &mut Backend) -> Result<()> {\n    if backend.state.player.queuestate.queue.is_empty() {\n        return Ok(());\n    }\n    \n    let currenturl = &backend.state.player.queuestate.queue[0].url;\n    \n    if let Some(mut process) = backend.mpvprocess.take() {\n        let _ = process.kill();\n    }\n    \n    backend.mpvprocess = Some(Command::new(\"mpv\")\n        .arg(currenturl)\n        .arg(\"--input-ipc-server=\".to_string() + MPVSOCKET)\n        .arg(\"--no-video\")\n        .arg(\"--no-terminal\")\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .spawn()?);\n    \n    backend.state.player.isplaying = true;\n    Ok(())\n}\n\n// --- navigation ---\n\npub fn nextcolumn(backend: &mut Backend) {\n    backend.selection.selectedcolumn = match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => CurrentColumn::Tracks,\n        CurrentColumn::Tracks => CurrentColumn::Queue,\n        CurrentColumn::Queue => CurrentColumn::Queue,\n    };\n}\n\npub fn prevcolumn(backend: &mut Backend) {\n    backend.selection.selectedcolumn = match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => CurrentColumn::Playlists,\n        CurrentColumn::Tracks => CurrentColumn::Playlists,\n        CurrentColumn::Queue => CurrentColumn::Tracks,\n    };\n}\n\npub fn nextrow(backend: &mut Backend) {\n    match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => {\n            let playlists_len = backend.state.playlists.len();\n            if playlists_len > 0 {\n                let current = backend.selection.playliststate.selected().unwrap_or(0);\n                let next = if current + 1 >= playlists_len {\n                    playlists_len - 1\n                } else {\n                    current + 1\n                };\n                backend.selection.playliststate.select(Some(next));\n            }\n        },\n        CurrentColumn::Tracks => {\n            if let Some(playlist_idx) = backend.selection.playliststate.selected() {\n                if let Some(playlist) = backend.state.playlists.get(playlist_idx) {\n                    let tracks_len = playlist.tracks.len();\n                    if tracks_len > 0 {\n                        let current = backend.selection.trackstate.selected().unwrap_or(0);\n                        let next = if current + 1 >= tracks_len {\n                            tracks_len - 1\n                        } else {\n                            current + 1\n                        };\n                        backend.selection.trackstate.select(Some(next));\n                    }\n                }\n            }\n        },\n        CurrentColumn::Queue => {\n            let queue_len = backend.state.player.queuestate.queue.len();\n            if queue_len > 0 {\n                let current = backend.selection.queuestate.selected().unwrap_or(0);\n                let next = if current + 1 >= queue_len {\n                    queue_len - 1\n                } else {\n                    current + 1\n                };\n                backend.selection.queuestate.select(Some(next));\n            }\n        }\n    }\n}\n\npub fn prevrow(backend: &mut Backend) {\n    match backend.selection.selectedcolumn {\n        CurrentColumn::Playlists => {\n            if !backend.state.playlists.is_empty() {\n                let current = backend.selection.playliststate.selected().unwrap_or(0);\n                let next = if current == 0 {\n                    0\n                } else {\n                    current - 1\n                };\n                backend.selection.playliststate.select(Some(next));\n            }\n        },\n        CurrentColumn::Tracks => {\n            if let Some(playlist_idx) = backend.selection.playliststate.selected() {\n                if let Some(_) = backend.state.playlists.get(playlist_idx) {\n                    let current = backend.selection.trackstate.selected().unwrap_or(0);\n                    let next = if current == 0 {\n                        0\n                    } else {\n                        current - 1\n                    };\n                    backend.selection.trackstate.select(Some(next));\n                }\n            }\n        },\n        CurrentColumn::Queue => {\n            if !backend.state.player.queuestate.queue.is_empty() {\n                let current = backend.selection.queuestate.selected().unwrap_or(0);\n                let next = if current == 0 {\n                    0\n                } else {\n                    current - 1\n                };\n                backend.selection.queuestate.select(Some(next));\n            }\n        }\n    }\n}\n"}