[["862a27e3-1e22-4904-a9fc-ff9495afc16c",{"value":{"selectedCode":"\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }","prefix":"// get.rs\n// backend read api\n\nuse super::Backend;\nuse crate::models::{AppState, CurrentColumn, PlayerState, Playlist, RepeatMode, Track, MPVSOCKET};\nuse anyhow::Result;\nuse std::process::{Command, Stdio};\nuse serde_json;\n\n// --- state access functions (for frontend to read) ---\npub fn state(backend: &Backend) -> &AppState {\n    &backend.state\n}\n\npub fn playingstate(backend: &Backend) -> &bool {\n    &backend.state.player.isplaying\n}\n\npub fn playerstate(backend: &Backend) -> &PlayerState {\n    &backend.state.player\n}\n\npub fn playlists(backend: &Backend) -> &Vec<Playlist> {\n    &backend.state.playlists\n}\n\npub fn repeatstate(backend: &Backend) -> &RepeatMode {\n    &backend.state.player.repeatstate.repeatmode\n}\n\npub fn shufflestate(backend: &Backend) -> &bool {\n    &backend.state.player.shufflestate.shuffle\n}\n\npub fn elapsedduration() -> Result<u32> {\n    // Check if socket exists before trying to use it\n    if !std::path::Path::new(MPVSOCKET).exists() {\n        return Err(anyhow::anyhow!(format!(\"socket file {} doesnt exist\", MPVSOCKET)));\n    }\n\n    // Add timeout for socket operations\n    let timeout = std::time::Duration::from_secs(2);\n\n    // unique request ID for this request\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"time-pos\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-T\")\n            .arg(timeout.as_secs().to_string())\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            return Err(anyhow::anyhow!(\"failed to get playback position from mpv: {}\", stderr));\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if data.is_null() {\n                    return Ok(0);\n                }\n","suffix":"\n        } else {\n            return Err(anyhow::anyhow!(\"json response could not be parsed\"))\n        }\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn totalduration() -> Result<u32> {\n    // Check if socket exists before trying to use it\n    if !std::path::Path::new(MPVSOCKET).exists() {\n        return Ok(0);\n    }\n\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"duration\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to get total duration from mpv: {}\", stderr);\n            return Ok(0);\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }\n        }\n\n        // return 0 if we couldn't parse the position\n        return Ok(0);\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn currentsong(backend: &Backend) -> Option<&Track> {\n    backend.state.player.queuestate.queue.get(0)\n}\n\npub fn queue(backend: &Backend) -> &Vec<Track> {\n    &backend.state.player.queuestate.queue\n}\n\npub fn playlisttracks(backend: &Backend, trackidx: usize) -> Option<Vec<Track>> {\n    if trackidx < backend.state.playlists.len() {\n        Some(backend.state.playlists[trackidx].tracks.clone())\n    } else {\n        None\n    }\n}\n\npub fn selectedcolumn(backend: &Backend) -> &CurrentColumn {\n    &backend.selection.selectedcolumn\n}\n\npub fn playlistsempty(backend: &Backend) -> bool {\n    backend.state.playlists.is_empty()\n}\n\npub fn queueempty(backend: &Backend) -> bool {\n    backend.state.player.queuestate.queue.is_empty()\n}\n\npub fn playliststate(backend: &Backend) -> &ratatui::widgets::ListState {\n    &backend.selection.playliststate\n}\n\npub fn trackstate(backend: &Backend) -> &ratatui::widgets::ListState {\n    &backend.selection.trackstate\n}\n\npub fn queuestate(backend: &Backend) -> &ratatui::widgets::ListState {\n    &backend.selection.queuestate\n}\n","path":"src/backend/get.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["f96e6a84-1fa6-4680-bea7-d0b0a094712a",{"value":{"selectedCode":"","prefix":"// get.rs\n// backend read api\n\nuse super::Backend;\nuse crate::models::{AppState, CurrentColumn, PlayerState, Playlist, RepeatMode, Track, MPVSOCKET};\nuse anyhow::Result;\nuse std::process::{Command, Stdio};\nuse serde_json;\n\n// --- state access functions (for frontend to read) ---\npub fn state(backend: &Backend) -> &AppState {\n    &backend.state\n}\n\npub fn playingstate(backend: &Backend) -> &bool {\n    &backend.state.player.isplaying\n}\n\npub fn playerstate(backend: &Backend) -> &PlayerState {\n    &backend.state.player\n}\n\npub fn playlists(backend: &Backend) -> &Vec<Playlist> {\n    &backend.state.playlists\n}\n\npub fn repeatstate(backend: &Backend) -> &RepeatMode {\n    &backend.state.player.repeatstate.repeatmode\n}\n\npub fn shufflestate(backend: &Backend) -> &bool {\n    &backend.state.player.shufflestate.shuffle\n}\n\npub fn elapsedduration(backend: &Backend) -> Result<u32> {\n    // Check if socket exists before trying to use it\n    if !std::path::Path::new(MPVSOCKET).exists() && playingstate(backend).to_owned() {\n        return Err(anyhow::anyhow!(format!(\"socket file {} doesnt exist\", MPVSOCKET)));\n    }\n\n    // Add timeout for socket operations\n    let timeout = std::time::Duration::from_secs(2);\n\n    // unique request ID for this request\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"time-pos\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-T\")\n            .arg(timeout.as_secs().to_string())\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            return Err(anyhow::anyhow!(\"failed to get playback position from mpv: {}\", stderr));\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if data.is_null() {\n                    return Ok(0);\n                }\n\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                } else {\n                    return Ok(0);\n                }\n            } else {\n                return Err(anyhow::anyhow!(\"no data in response: {}\", response))\n            }\n        } else {\n            return Err(anyhow::anyhow!(\"json response could not be parsed: {}\", response))\n        }\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn totalduration(backend: &Backend) -> Result<u32> {\n    // Check if socket exists before trying to use it\n    if !std::path::Path::new(MPVSOCKET).exists() {\n        return Ok(0);\n    }\n","suffix":"\n    let requestid = rand::random::<u32>();\n\n    let echoout = Command::new(\"echo\")\n        .arg(format!(r#\"{{\"command\":[\"get_property\",\"duration\"], \"request_id\": {}}}\"#, requestid))\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    if let Some(echoout) = echoout.stdout {\n        // send the command to mpv via socket and capture the output\n        let socatout = Command::new(\"socat\")\n            .arg(\"-\")\n            .arg(MPVSOCKET)\n            .stdin(Stdio::from(echoout))\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()?;\n\n        if !socatout.status.success() {\n            let stderr = String::from_utf8_lossy(&socatout.stderr);\n            eprintln!(\"failed to get total duration from mpv: {}\", stderr);\n            return Ok(0);\n        }\n\n        // parse the JSON response\n        let response = String::from_utf8_lossy(&socatout.stdout);\n\n        // parse the response JSON\n        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response) {\n            // extract the position value\n            if let Some(data) = json.get(\"data\") {\n                if let Some(position) = data.as_f64() {\n                    return Ok(position.floor() as u32); // convert to u32 (seconds)\n                }\n            }\n        }\n\n        // return 0 if we couldn't parse the position\n        return Ok(0);\n    } else {\n        eprintln!(\"failed to get stdout from echo command\");\n        return Ok(0); // return 0 on error\n    }\n}\n\npub fn currentsong(backend: &Backend) -> Option<&Track> {\n    backend.state.player.queuestate.queue.get(0)\n}\n\npub fn queue(backend: &Backend) -> &Vec<Track> {\n    &backend.state.player.queuestate.queue\n}\n\npub fn playlisttracks(backend: &Backend, trackidx: usize) -> Option<Vec<Track>> {\n    if trackidx < backend.state.playlists.len() {\n        Some(backend.state.playlists[trackidx].tracks.clone())\n    } else {\n        None\n    }\n}\n\npub fn selectedcolumn(backend: &Backend) -> &CurrentColumn {\n    &backend.selection.selectedcolumn\n}\n\npub fn playlistsempty(backend: &Backend) -> bool {\n    backend.state.playlists.is_empty()\n}\n\npub fn queueempty(backend: &Backend) -> bool {\n    backend.state.player.queuestate.queue.is_empty()\n}\n\npub fn playliststate(backend: &Backend) -> &ratatui::widgets::ListState {\n    &backend.selection.playliststate\n}\n\npub fn trackstate(backend: &Backend) -> &ratatui::widgets::ListState {\n    &backend.selection.trackstate\n}\n\npub fn queuestate(backend: &Backend) -> &ratatui::widgets::ListState {\n    &backend.selection.queuestate\n}\n","path":"src/backend/get.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}],["74c96329-77df-4cd8-9bda-bef58f070879",{"value":{"selectedCode":"","prefix":"// frontend.rs\n// handles drawing, etc\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect}, style::{Color, Style}, text::{Line, Text}, widgets::{Block, BorderType, Borders, Gauge, List, ListItem, Paragraph}, Frame\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{\n    backend::CrosstermBackend,\n    Terminal,\n};\nuse std::io;\nuse std::time::Duration;\n\nuse crate::{backend::{self, Backend}, models::{Playlist, RepeatMode}};\nuse crate::models::{CurrentColumn, SONGINFOPERCENT, Track, VERSION};\n\n#[derive(Clone, Debug)]\npub struct PopupState {\n    pub onscreen: bool,\n    pub title: String,\n    pub header: String,\n    pub message: Vec<String>,\n    pub dangerous: bool,\n}\n\npub struct App {\n    pub version: String,\n    pub popup: PopupState,\n}\n\nimpl App {\n    pub fn new(version: String) -> Self {\n        Self {\n            version,\n            popup: PopupState {\n                onscreen: false,\n                title: String::new(),\n                header: String::new(),\n                message: Vec::new(),\n                dangerous: false,\n            },\n        }\n    }\n}\n\npub fn runfrontend(mut backend: Backend) -> Result<()> {\n    // --- setup terminal ---\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backendtui = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backendtui)?;\n\n    // --- initialize ui state ---\n    let mut running = true;\n    let mut app = App::new(VERSION.to_string());\n\n    // --- main loop ---\n    let mut counter: u8 = 0;\n    while running {\n        let elapsed = backend::get::elapsedduration(&backend)?;\n        let total = backend::get::totalduration(&backend)?;\n","suffix":"        let isplaying = *backend::get::playingstate(&backend);\n        let selectedcolumn = backend::get::selectedcolumn(&backend);\n        let mut playliststate = backend::get::playliststate(&backend).clone();\n        if playliststate.selected().is_none() && !backend::get::playlistsempty(&backend) {\n            playliststate.select(Some(0));\n        }\n\n        let selectedplaylistidx = playliststate.selected();\n        let trackstodisplay = if let Some(playlistidx) = selectedplaylistidx {\n            backend::get::playlisttracks(&backend, playlistidx).unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n        \n        let mut trackstate = backend.selection.trackstate.clone();\n        if trackstate.selected().is_none() && !trackstodisplay.is_empty() {\n            trackstate.select(Some(0));\n        }\n        \n        let mut queuestate = backend.selection.queuestate.clone();\n        if queuestate.selected().is_none() && !backend::get::queueempty(&backend) {\n            queuestate.select(Some(0));\n        }\n        \n        terminal.draw(|frame| {\n            let area = frame.area();\n            let (playlists, tracks, queue, controls, songname, progressbar, credits) =\n                construct(area, &isplaying);\n\n            let playlistscont = getplaylistscont(backend::get::playlists(&backend), selectedcolumn == &CurrentColumn::Playlists);\n            let trackscont = gettrackscont(&trackstodisplay, selectedcolumn == &CurrentColumn::Tracks);\n            let queuecont = getqueuecont(backend::get::queue(&backend), selectedcolumn == &CurrentColumn::Queue);\n            let controlscont = getcontrolscontent(&isplaying);\n            let songinfocont = backend::get::currentsong(&backend)\n                .map(|track| getsonginfocont(track, \n                                            *backend::get::shufflestate(&backend), \n                                            backend::get::repeatstate(&backend).clone()))\n                .unwrap_or_else(|| getsonginfocont(&Track::default(), false, RepeatMode::None));\n            let progressbarcont = getprogressbarcont(&elapsed, &total);\n            let creditscont = getcreditscont(VERSION);\n            \n            renderpopup(&app, frame);\n            frame.render_stateful_widget(playlistscont, playlists, &mut playliststate);\n            frame.render_stateful_widget(trackscont, tracks, &mut trackstate);\n            frame.render_stateful_widget(queuecont, queue, &mut queuestate);\n            frame.render_widget(controlscont, controls);\n            frame.render_widget(songinfocont, songname);\n            frame.render_widget(progressbarcont, progressbar);\n            frame.render_widget(creditscont, credits);\n        })?;\n\n        // handle input\n        let popupopen = app.popup.onscreen;\n        if event::poll(Duration::from_millis(250))? {\n            if let Event::Key(key) = event::read()? {\n                if key.kind == KeyEventKind::Press {\n                    if let Err(e) = handleinput(&mut backend, &mut app, &mut running, key.code, popupopen) {\n                        newpopup(&mut app, \n                            \"Error\".to_string(),\n                            vec![format!(\"Input error: {}\", e)],\n                            true\n                        );\n                    }\n                }\n            }\n        }\n\n        // handle periodic updates (e.g., track progress)\n        counter = (counter + 1) % 4;\n        if counter == 0 {\n            // TODO: update currenttime or check track end via backend\n        }\n    }\n\n    // --- cleanup ---\n    let _ = backend.shutdown();\n    execute!(io::stdout(), LeaveAlternateScreen)?;\n    disable_raw_mode()?;\n\n    Ok(())\n}\n\nfn handleinput(\n    backend: &mut Backend,\n    app: &mut App,\n    running: &mut bool,\n    key: KeyCode,\n    popupopen: bool,\n) -> Result<()> {\n    if popupopen.to_owned() {\n        if key == KeyCode::Char('q') || key == KeyCode::Esc {\n            closepopup(app);\n        }\n        return Ok(());\n    }\n\n    // handle input based on app state\n    match key {\n        KeyCode::Char('q') => *running = false,\n        KeyCode::Char(' ') => backend::set::playpause(backend)?, // toggle play/pause\n        KeyCode::Char('>') => backend::set::next(backend)?,\n        KeyCode::Char('<') => backend::set::prev(backend)?, // TODO: restart song when < 10 secs\n        KeyCode::Char('s') => backend::set::toggleshuffle(backend),\n        KeyCode::Char('r') => backend::set::cyclerepeat(backend),\n        KeyCode::Up => backend::set::prevrow(backend),\n        KeyCode::Down => backend::set::nextrow(backend),\n        KeyCode::Left => backend::set::prevcolumn(backend),\n        KeyCode::Right => backend::set::nextcolumn(backend),\n        KeyCode::Enter => { /* ... play selected track or playlist ... */ }\n        _ => {}\n    }\n    Ok(())\n}\n\n\n/// main constructor\n/// \n/// # arguments\n/// * 'area' - the area to split up into individual areas\n/// \n/// # returns\n/// * a tuple of six rects:\n///     * playlists\n///     * tracks\n///     * queue\n///     * controls\n///     * songinfo\n///     * progressbar\npub fn construct(area: Rect, isplaying: &bool) -> (Rect, Rect, Rect, Rect, Rect, Rect, Rect) {\n    let verticalchunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Percentage(100),// tracks views\n                Constraint::Min(3),         // controls/info\n                Constraint::Length(1)       // credits\n            ])\n            .split(area);\n\n    let toplayout = verticalchunks[0];\n    let bottomlayout = verticalchunks[1];\n\n    let topchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Fill(2),            // playlists\n                Constraint::Fill(5),            // tracks\n                Constraint::Fill(2)             // queue\n            ])\n            .split(toplayout);\n\n    let bottomchunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints(\n                if isplaying.to_owned() {[\n                    Constraint::Length(21),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]} else {[\n                    Constraint::Length(20),                     // controls\n                    Constraint::Percentage(SONGINFOPERCENT),    // song name\n                    Constraint::Min(20)                         // progress bar\n                ]}\n            )\n            .split(bottomlayout);\n\n    let playlists = topchunks[0];\n    let tracks = topchunks[1];\n    let queue = topchunks[2];\n\n    let controls = bottomchunks[0];\n    let songname = bottomchunks[1];\n    let progressbar = bottomchunks[2];\n\n    let credits = verticalchunks[2];\n\n    (playlists, tracks, queue, controls, songname, progressbar, credits)\n}\n\nfn getcontrolscontent(isplaying: &bool) -> Paragraph {\n    let text = if !isplaying.to_owned() {\n        String::from(\"[<<] [ play ] [>>]\")\n    } else {\n        String::from(\"[<<] [ pause ] [>>]\")\n    };\n\n    Paragraph::new(text)\n        .block(\n            Block::new()\n                .title(\" controls \")\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Center)\n}\n\nfn getplaylistscont(playlists: &Vec<Playlist>, infocus: bool) -> List {\n    // gets the list of playlists\n    let playlistitems: Vec<ListItem> = playlists\n        .iter()\n        .map(|p| ListItem::new(format!(\" {}\", p.name.as_str())))\n        .collect();\n\n    let playlistslist = List::new(playlistitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" playlists \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::Black)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    playlistslist\n}\n\nfn gettrackscont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(format!(\" {} - {}\", t.title.as_str(), t.artist.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" tracks \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::Black)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\nfn getqueuecont(tracks: &Vec<Track>, infocus: bool) -> List {\n    // gets the list of tracks\n    let trackitems: Vec<ListItem> = tracks\n        .iter()\n        .map(|t| ListItem::new(String::from(t.title.as_str())))\n        .collect();\n\n    let trackslist = List::new(trackitems)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_style(\n                    if infocus {\n                        Style::default().fg(Color::Magenta)\n                    } else {\n                        Style::default()\n                    }\n                )\n                .border_type(\n                    if infocus {\n                        BorderType::Thick\n                    } else {\n                        BorderType::Rounded\n                    }\n                )\n                .title(\" queue \")\n        )\n        .highlight_style(\n            if infocus {\n                Style::default().bg(Color::Magenta).fg(Color::Black)\n            } else {\n                Style::default().bg(Color::LightMagenta).fg(Color::White)\n            }\n        )\n        .highlight_symbol(\"> \");\n\n    trackslist\n}\n\n\n// These functions have been moved to models.rs\n\nfn getprogressbarcont(currenttime: &u32, totaltime: &u32) -> Gauge<'static> {\n    let current = currenttime.to_owned();\n    let total = totaltime.to_owned();\n    // gets the progressbar \n    let currentprogress: String = getprettyduration(current);\n    let totalprogress: String = getprettyduration(total);\n    let currentprogressratio;\n    if total == 0 {\n        currentprogressratio = 0f64;\n    } else {\n        currentprogressratio = current as f64/total as f64;\n    }\n\n    Gauge::default()\n        .block(\n            Block::default().title(format!(\" {}/{} \", currentprogress, totalprogress))\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded)\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .gauge_style(Style::default().fg(Color::LightMagenta))\n        .label(\"\")\n        .ratio(currentprogressratio)\n}\n\nfn getprettyduration(secs: u32) -> String {\n    let minutes = secs / 60;\n    let seconds = secs % 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n\nfn getcreditscont(version: &str) -> Block {\n    // gets the credits\n    Block::new()\n        .title_top(format!(\"mpvlayer ── v{} \", version))\n        .title_top(Line::from(\" https://github.com/ellipticobj/mpvlayer\").right_aligned())\n        .border_type(BorderType::Rounded)\n        .borders(Borders::TOP)\n}\n\npub fn getsonginfocont(track: &Track, shuffle: bool, repeat: RepeatMode) -> ratatui::widgets::Paragraph<'static> {\n    use ratatui::{style::{Color, Style}, text::Line, widgets::{Block, BorderType, Borders, Paragraph}};\n\n    // --- create display text based on track info ---\n    let displaytext: String = if track.artist.is_empty() {\n        String::from(format!(\" {} \", track.title))\n    } else if track.title.is_empty() {\n        String::from(format!(\" Unknown Track - {} \", track.artist))\n    } else {\n        String::from(format!(\" {} - {} \", track.title, track.artist))\n    };\n\n    // --- get controls state string ---\n    let controlsstatestring = getcontrolsstate(shuffle, repeat);\n    let controlsstateline = Line::from(format!(\" {} \", controlsstatestring)).right_aligned();\n\n    // --- build the final Paragraph ---\n    Paragraph::new(displaytext)\n        .block(\n            Block::default()\n                .title_top(\" currently playing \")\n                .title_top(controlsstateline)\n                .border_type(BorderType::Rounded)\n                .borders(Borders::ALL),\n        )\n        .style(Style::default().fg(Color::Magenta))\n        .alignment(ratatui::layout::Alignment::Left)\n}\n\npub fn getcontrolsstate(shuffle: bool, repeat: RepeatMode) -> String {\n    // gets the state of shuffle and repeat\n    let mut controls: Vec<String> = Vec::new();\n    if shuffle {\n        controls.push(String::from(\"shuffle on ─\")); // extra dash so the text stays still call me a sigma\n    } else {\n        controls.push(String::from(\"shuffle off \"));\n    }\n\n    match repeat {\n        RepeatMode::None => controls.push(String::from(\" repeat off\")),\n        RepeatMode::One => controls.push(String::from(\" repeat one\")),\n        RepeatMode::All => controls.push(String::from(\" repeat all\"))\n    }\n\n    controls.join(\"──\")\n}\n\n/// centers a rect\n/// \n/// # arguments\n/// * `rect` - the rect to center\n/// * `area` - the area to center in\n/// \n/// # returns\n/// * the centered rect\npub fn centerrect(rect: Rect, area: Rect) -> Rect {\n    let x = (area.width - rect.width) / 2;\n    let y = (area.height - rect.height) / 2;\n    Rect::new(x, y, rect.width, rect.height)\n}\n\npub fn renderpopup(app: &App, frame: &mut Frame) {\n    if app.popup.onscreen {\n        let area = frame.area();\n        let popuparea = centerrect(Rect::new(0, 0, 40, 10), area);\n        let popupcont = Paragraph::new(Text::from(app.popup.message.clone().iter().map(|s| Line::from(s.clone())).collect::<Vec<Line>>()))\n            .block(Block::default().title(app.popup.title.clone()).borders(Borders::ALL))\n            .style(Style::default().fg(Color::Magenta))\n            .alignment(ratatui::layout::Alignment::Left);\n        frame.render_widget(popupcont, popuparea);\n    }\n}\n\npub fn newpopup(app: &mut App, title: String, message: Vec<String>, dangerous: bool) {\n    app.popup.onscreen = true;\n    app.popup.title = title;\n    app.popup.message = message;\n    app.popup.dangerous = dangerous;\n}\n\npub fn closepopup(app: &mut App) {\n    app.popup.onscreen = false;\n    app.popup.title = String::from(\"\");\n    app.popup.message = Vec::new();\n    app.popup.dangerous = false;\n}\n","path":"src/frontend.rs","language":"rust","prefixBegin":0,"suffixEnd":0}}]]